<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>MiniCraft (Minecraft-style)</title>
  <style>
    :root{
      --bg:#070914;
      --panel:rgba(255,255,255,0.10);
      --panel2:rgba(255,255,255,0.06);
      --border:rgba(255,255,255,0.16);
      --text:#f2f6ff;
      --muted:rgba(242,246,255,0.76);
      --accent:#22ffb6;
      --gold:#ffd84d;
      --danger:#ff4d6d;
      --shadow: rgba(0,0,0,0.45);
    }
    *{ box-sizing:border-box; }
    html, body{ height:100%; }
    body{
      margin:0;
      font-family: Verdana, "Comic Sans MS", system-ui, sans-serif;
      background:
        radial-gradient(1000px 700px at 50% 20%, rgba(34,255,182,0.12) 0%, rgba(7,9,20,0) 55%),
        radial-gradient(900px 650px at 80% 75%, rgba(255,216,77,0.10) 0%, rgba(7,9,20,0) 60%),
        radial-gradient(900px 650px at 20% 85%, rgba(255,77,109,0.10) 0%, rgba(7,9,20,0) 60%),
        var(--bg);
      overflow:hidden;
      touch-action: none;
      -webkit-user-select:none;
      user-select:none;
    }
    .wrap{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:14px;
    }
    .card{
      width:min(1100px, 96vw);
      height:min(720px, 92vh);
      border-radius:18px;
      border:1px solid var(--border);
      background:linear-gradient(180deg, var(--panel), var(--panel2));
      box-shadow: 0 24px 80px var(--shadow);
      overflow:hidden;
      position:relative;
    }
    canvas{
      width:100%;
      height:100%;
      display:block;
    }
    .overlay{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
      background: radial-gradient(900px 500px at 50% 25%, rgba(91,247,255,0.12), rgba(0,0,0,0.72));
    }
    .overlay.hidden{ display:none; }
    .panel{
      width:min(640px, 92vw);
      border-radius:18px;
      border:1px solid var(--border);
      background:linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.06));
      box-shadow: 0 24px 80px rgba(0,0,0,0.50);
      padding:14px 14px 12px;
      text-align:left;
    }
    h1{
      margin:0 0 8px 0;
      font-size:26px;
      letter-spacing:0.3px;
      text-shadow: 0 0 18px rgba(34,255,182,0.25);
    }
    .sub{
      margin:0;
      color:var(--muted);
      font-weight:800;
      font-size:13px;
      line-height:1.45;
    }
    .row{
      margin-top:10px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.14);
      background:rgba(0,0,0,0.28);
      color:var(--text);
      font-weight:900;
      font-size:12px;
    }
    button{
      appearance:none;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(0,0,0,0.30);
      color:var(--text);
      font-weight:900;
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
    }
    button.primary{
      background:linear-gradient(180deg, rgba(34,255,182,0.22), rgba(34,255,182,0.10));
      border-color: rgba(34,255,182,0.35);
      box-shadow: 0 0 24px rgba(34,255,182,0.18);
    }
    .kbd{
      display:inline-block;
      padding:2px 6px;
      border:1px solid rgba(255,255,255,0.18);
      border-bottom-color: rgba(255,255,255,0.30);
      border-radius:8px;
      background: rgba(0,0,0,0.28);
      font-weight:1000;
    }

    /* Touch controls */
    .touchUI{
      position:absolute;
      inset:0;
      pointer-events:none;
    }
    .touchBtn{
      pointer-events:auto;
      position:absolute;
      width:64px;
      height:64px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(0,0,0,0.28);
      color:rgba(242,246,255,0.90);
      font-weight:1000;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
      -webkit-user-select:none;
    }
    .touchBtn.small{
      width:56px;height:56px;border-radius:14px;
      font-size:12px;
    }
    .touchBtn.on{
      border-color: rgba(34,255,182,0.45);
      box-shadow: 0 0 18px rgba(34,255,182,0.18);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <canvas id="c"></canvas>

      <div class="touchUI" id="touchUI">
        <div class="touchBtn" id="btnLeft" style="left:14px;bottom:18px;">◀</div>
        <div class="touchBtn" id="btnRight" style="left:92px;bottom:18px;">▶</div>
        <div class="touchBtn" id="btnJump" style="right:14px;bottom:18px;">⤒</div>

        <div class="touchBtn small" id="btnMine" style="right:86px;bottom:18px;">MINE</div>
        <div class="touchBtn small" id="btnPlace" style="right:158px;bottom:18px;">PLACE</div>
      </div>

      <div class="overlay" id="overlay">
        <div class="panel">
          <h1>MiniCraft</h1>
          <p class="sub">
            Minecraft-style block game (2D). Mine blocks, place blocks, and build stuff.
          </p>
          <div class="row">
            <span class="pill">Keyboard: <span class="kbd">A/D</span> or <span class="kbd">←/→</span> move • <span class="kbd">Space</span> jump</span>
            <span class="pill"><span class="kbd">E</span> mine • <span class="kbd">Q</span> place</span>
            <span class="pill"><span class="kbd">1-5</span> hotbar</span>
          </div>
          <div class="row">
            <span class="pill">iPad/Touch: use buttons, then tap <b>MINE</b> / <b>PLACE</b></span>
          </div>
          <div class="row" style="margin-top:12px">
            <button class="primary" id="btnPlay">Play</button>
            <button id="btnReset">Reset Save</button>
          </div>
          <p class="sub" style="margin-top:10px">
            Tip: Mine the block in front of you. Place the selected block in front of you.
          </p>
        </div>
      </div>
    </div>
  </div>

<script>
(function(){
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const overlay = document.getElementById('overlay');
  const btnPlay = document.getElementById('btnPlay');
  const btnReset = document.getElementById('btnReset');

  const btnLeft = document.getElementById('btnLeft');
  const btnRight = document.getElementById('btnRight');
  const btnJump = document.getElementById('btnJump');
  const btnMine = document.getElementById('btnMine');
  const btnPlace = document.getElementById('btnPlace');

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const now = () => performance.now();

  // --- World ---
  const TILE = 28;
  const WORLD_W = 220;
  const WORLD_H = 90;

  const AIR = 0, GRASS = 1, DIRT = 2, STONE = 3, WOOD = 4, LEAF = 5;
  const tileName = ['Air','Grass','Dirt','Stone','Wood','Leaf'];
  const solid = [false,true,true,true,true,false];

  const colors = {};
  colors[AIR] = null;
  colors[GRASS] = '#2eea74';
  colors[DIRT] = '#8b5a2b';
  colors[STONE] = '#8d98a5';
  colors[WOOD] = '#a56a3a';
  colors[LEAF] = '#1ebc55';

  // Only store diffs in localStorage
  const LS = {
    seed: 'minicraft_seed_v1',
    diff: 'minicraft_diff_v1',
    inv: 'minicraft_inv_v1',
    coins: 'minicraft_coins_v1'
  };

  function hashSeed(s){
    let h = 2166136261 >>> 0;
    for (let i=0;i<s.length;i++){
      h ^= s.charCodeAt(i);
      h = Math.imul(h, 16777619) >>> 0;
    }
    return h >>> 0;
  }
  function seeded(seed){
    let x = seed >>> 0;
    return function(){
      x = (Math.imul(x, 1664525) + 1013904223) >>> 0;
      return x / 4294967296;
    };
  }

  function k(x,y){ return x + ',' + y; }

  let base = null; // Uint8Array
  let diff = {};   // { "x,y": tileId }
  let seedStr = '';
  let rng = null;

  function getTile(x,y){
    if (x < 0 || y < 0 || x >= WORLD_W || y >= WORLD_H) return STONE; // outside is solid
    const key = k(x,y);
    if (diff.hasOwnProperty(key)) return diff[key];
    return base[y*WORLD_W + x];
  }
  function setTile(x,y,v){
    if (x < 0 || y < 0 || x >= WORLD_W || y >= WORLD_H) return;
    const key = k(x,y);
    const b = base[y*WORLD_W + x];
    if (v === b){
      if (diff.hasOwnProperty(key)) delete diff[key];
    } else {
      diff[key] = v;
    }
  }

  function genWorld(){
    base = new Uint8Array(WORLD_W * WORLD_H);
    for (let i=0;i<base.length;i++) base[i] = AIR;

    // Height map with smooth noise
    const height = new Array(WORLD_W);
    let h = Math.floor(WORLD_H*0.55);
    for (let x=0;x<WORLD_W;x++){
      h += Math.floor((rng()-0.5) * 3);
      if (x % 9 === 0) h += Math.floor((rng()-0.5) * 6);
      h = clamp(h, Math.floor(WORLD_H*0.35), Math.floor(WORLD_H*0.72));
      height[x] = h;
    }

    for (let x=0;x<WORLD_W;x++){
      const surface = height[x];
      for (let y=surface;y<WORLD_H;y++){
        let t = DIRT;
        if (y === surface) t = GRASS;
        else if (y > surface + 4) t = STONE;
        base[y*WORLD_W + x] = t;
      }
    }

    // Trees
    for (let x=6;x<WORLD_W-6;x++){
      if (rng() < 0.065){
        const s = height[x];
        // avoid too close to previous
        if (rng() < 0.5) x += 3;
        const trunkH = 4 + Math.floor(rng()*4);
        for (let i=0;i<trunkH;i++){
          const y = s - 1 - i;
          if (y > 0) base[y*WORLD_W + x] = WOOD;
        }
        const topY = s - 1 - trunkH;
        for (let ox=-2;ox<=2;ox++){
          for (let oy=-2;oy<=2;oy++){
            if (Math.abs(ox)+Math.abs(oy) > 3) continue;
            const xx = x+ox, yy = topY+oy;
            if (xx<=0||yy<=0||xx>=WORLD_W-1||yy>=WORLD_H-1) continue;
            if (base[yy*WORLD_W + xx] === AIR) base[yy*WORLD_W + xx] = LEAF;
          }
        }
      }
    }

    diff = loadDiff();
  }

  function loadDiff(){
    try{
      const s = localStorage.getItem(LS.diff);
      if (!s) return {};
      const o = JSON.parse(s);
      return o && typeof o === 'object' ? o : {};
    } catch {
      return {};
    }
  }
  function saveAll(){
    try{
      localStorage.setItem(LS.seed, seedStr);
      localStorage.setItem(LS.diff, JSON.stringify(diff));
      localStorage.setItem(LS.inv, JSON.stringify(inv));
    } catch {}
  }
  function resetSave(){
    try{
      localStorage.removeItem(LS.seed);
      localStorage.removeItem(LS.diff);
      localStorage.removeItem(LS.inv);
    } catch {}
  }

  // --- Player ---
  const keys = {};
  function setKey(k, v){ keys[k] = v; }
  document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') e.preventDefault();
    setKey(e.key, true);
  });
  document.addEventListener('keyup', (e) => setKey(e.key, false));

  const player = {
    x: 12*TILE,
    y: 10*TILE,
    vx: 0,
    vy: 0,
    w: TILE*0.62,
    h: TILE*0.92,
    onGround: false,
    face: 1,
  };

  // --- Inventory / hotbar ---
  // slots: 0 Dirt, 1 Stone, 2 Wood, 3 Leaf, 4 "Hand"
  const inv = {
    sel: 0,
    dirt: 0,
    stone: 0,
    wood: 0,
    leaf: 0,
  };
  function loadInv(){
    try{
      const s = localStorage.getItem(LS.inv);
      if (!s) return;
      const o = JSON.parse(s);
      if (!o) return;
      inv.sel = o.sel|0;
      inv.dirt = o.dirt|0;
      inv.stone = o.stone|0;
      inv.wood = o.wood|0;
      inv.leaf = o.leaf|0;
    } catch {}
  }
  function giveTile(t){
    if (t === DIRT || t === GRASS) inv.dirt++;
    else if (t === STONE) inv.stone++;
    else if (t === WOOD) inv.wood++;
    else if (t === LEAF) inv.leaf++;
  }
  function takeSelected(){
    if (inv.sel === 0){ if (inv.dirt<=0) return false; inv.dirt--; return DIRT; }
    if (inv.sel === 1){ if (inv.stone<=0) return false; inv.stone--; return STONE; }
    if (inv.sel === 2){ if (inv.wood<=0) return false; inv.wood--; return WOOD; }
    if (inv.sel === 3){ if (inv.leaf<=0) return false; inv.leaf--; return LEAF; }
    return false;
  }

  document.addEventListener('keydown', (e) => {
    if (e.key >= '1' && e.key <= '5'){
      inv.sel = (e.key.charCodeAt(0) - 49);
    }
  });

  // --- Mining / placing ---
  let mineHold = false;
  let placeHold = false;
  let mineProg = 0;
  let mineTarget = null; // {x,y,t}

  function frontBlock(){
    // target block in front of player (at chest height)
    const px = player.x + player.w*0.5;
    const py = player.y + player.h*0.55;
    const dist = TILE*1.0;
    const tx = Math.floor((px + player.face*dist) / TILE);
    const ty = Math.floor(py / TILE);
    return { x: tx, y: ty };
  }

  function tryMine(dt){
    const b = frontBlock();
    const t = getTile(b.x, b.y);
    if (!solid[t] && t !== WOOD) { // allow mining wood too, leaf not solid but mineable? keep leaf mineable too
      if (t === LEAF) {}
      else return;
    }
    if (t === AIR) return;

    const same = mineTarget && mineTarget.x === b.x && mineTarget.y === b.y && mineTarget.t === t;
    if (!same){
      mineTarget = { x:b.x, y:b.y, t };
      mineProg = 0;
    }

    // hardness
    let time = 0.55;
    if (t === STONE) time = 0.95;
    if (t === WOOD) time = 0.75;
    if (t === LEAF) time = 0.25;

    mineProg += dt / time;
    if (mineProg >= 1){
      setTile(b.x, b.y, AIR);
      giveTile(t);
      mineProg = 0;
      mineTarget = null;
      saveSoon();
    }
  }

  function tryPlace(){
    const b = frontBlock();
    if (getTile(b.x, b.y) !== AIR) return;
    const put = takeSelected();
    if (!put) return;
    setTile(b.x, b.y, put);
    saveSoon();
  }

  // --- Touch buttons ---
  function bindHold(el, onDown, onUp){
    function down(e){ e.preventDefault(); onDown(); }
    function up(e){ e.preventDefault(); onUp(); }
    el.addEventListener('pointerdown', down, { passive:false });
    el.addEventListener('pointerup', up, { passive:false });
    el.addEventListener('pointercancel', up, { passive:false });
    el.addEventListener('pointerleave', up, { passive:false });
  }
  bindHold(btnLeft, () => { setKey('ArrowLeft', true); btnLeft.classList.add('on'); }, () => { setKey('ArrowLeft', false); btnLeft.classList.remove('on'); });
  bindHold(btnRight, () => { setKey('ArrowRight', true); btnRight.classList.add('on'); }, () => { setKey('ArrowRight', false); btnRight.classList.remove('on'); });
  bindHold(btnJump, () => { setKey(' ', true); setKey('Space', true); btnJump.classList.add('on'); }, () => { setKey(' ', false); setKey('Space', false); btnJump.classList.remove('on'); });
  bindHold(btnMine, () => { mineHold = true; btnMine.classList.add('on'); }, () => { mineHold = false; btnMine.classList.remove('on'); mineProg = 0; mineTarget = null; });
  btnPlace.addEventListener('pointerdown', (e) => { e.preventDefault(); tryPlace(); btnPlace.classList.add('on'); setTimeout(() => btnPlace.classList.remove('on'), 120); }, { passive:false });

  // Mouse/touch: hold to mine, right click to place
  canvas.addEventListener('contextmenu', (e) => e.preventDefault());
  canvas.addEventListener('pointerdown', (e) => {
    if (!running) return;
    e.preventDefault();
    // Don't start mining if you're tapping the hotbar area
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left);
    const y = (e.clientY - rect.top);
    const W = viewW || rect.width, H = viewH || rect.height;
    const hbY = H - 64;
    const hbX = Math.floor(W*0.5 - 5*48*0.5);
    if (y >= hbY && y <= hbY + 44 && x >= hbX && x <= hbX + 5*48){
      return;
    }
    if (e.button === 2){
      tryPlace();
    } else {
      mineHold = true;
    }
  }, { passive:false });
  canvas.addEventListener('pointerup', (e) => { e.preventDefault(); mineHold = false; mineProg = 0; mineTarget = null; }, { passive:false });
  canvas.addEventListener('pointercancel', (e) => { e.preventDefault(); mineHold = false; mineProg = 0; mineTarget = null; }, { passive:false });

  document.addEventListener('keydown', (e) => {
    if (!running) return;
    if (e.key === 'e' || e.key === 'E') mineHold = true;
    if (e.key === 'q' || e.key === 'Q') tryPlace();
  });
  document.addEventListener('keyup', (e) => {
    if (e.key === 'e' || e.key === 'E'){ mineHold = false; mineProg = 0; mineTarget = null; }
  });

  // --- Camera ---
  let camX = 0, camY = 0;
  let viewW = 0, viewH = 0, viewDpr = 1;

  function resize(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const r = canvas.getBoundingClientRect();
    viewW = Math.max(320, Math.floor(r.width));
    viewH = Math.max(240, Math.floor(r.height));
    viewDpr = dpr;
    canvas.width = Math.floor(viewW * dpr);
    canvas.height = Math.floor(viewH * dpr);
    // Draw in CSS pixels (so logic uses viewW/viewH, not canvas.width)
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.imageSmoothingEnabled = false;
  }
  window.addEventListener('resize', resize);
  requestAnimationFrame(resize);

  // --- Collision helpers ---
  function aabbVsTile(px,py,pw,ph, tx,ty){
    const x0 = tx*TILE, y0 = ty*TILE;
    return (px < x0+TILE && px+pw > x0 && py < y0+TILE && py+ph > y0);
  }

  function moveAndCollide(dt){
    const speed = 360;
    const accel = 2200;
    const friction = Math.pow(0.86, dt*60);
    const grav = 2400;
    const jumpV = 820;

    const left = keys['ArrowLeft'] || keys['a'] || keys['A'];
    const right = keys['ArrowRight'] || keys['d'] || keys['D'];
    const jump = keys[' '] || keys['Space'];

    let ax = 0;
    if (left) ax -= accel;
    if (right) ax += accel;
    if (ax !== 0) player.face = ax > 0 ? 1 : -1;

    player.vx += ax * dt;
    player.vx = clamp(player.vx, -speed, speed);
    if (ax === 0) player.vx *= friction;

    player.vy += grav * dt;
    player.vy = clamp(player.vy, -9999, 2400);

    if (jump && player.onGround){
      player.vy = -jumpV;
      player.onGround = false;
    }

    // X
    player.x += player.vx * dt;
    collideAxis('x');
    // Y
    player.y += player.vy * dt;
    collideAxis('y');
  }

  function collideAxis(axis){
    const px = player.x, py = player.y, pw = player.w, ph = player.h;
    const minX = Math.floor(px / TILE) - 2;
    const maxX = Math.floor((px+pw) / TILE) + 2;
    const minY = Math.floor(py / TILE) - 2;
    const maxY = Math.floor((py+ph) / TILE) + 2;

    if (axis === 'y') player.onGround = false;

    for (let y=minY;y<=maxY;y++){
      for (let x=minX;x<=maxX;x++){
        const t = getTile(x,y);
        if (!solid[t]) continue;
        if (!aabbVsTile(player.x, player.y, pw, ph, x, y)) continue;
        const tx0 = x*TILE, ty0 = y*TILE;
        if (axis === 'x'){
          if (player.vx > 0){
            player.x = tx0 - pw - 0.01;
          } else if (player.vx < 0){
            player.x = tx0 + TILE + 0.01;
          }
          player.vx = 0;
        } else {
          if (player.vy > 0){
            player.y = ty0 - ph - 0.01;
            player.vy = 0;
            player.onGround = true;
          } else if (player.vy < 0){
            player.y = ty0 + TILE + 0.01;
            player.vy = 0;
          }
        }
      }
    }
  }

  // --- Save throttling ---
  let saveTimer = 0;
  function saveSoon(){ saveTimer = 0.35; }
  function saveTick(dt){
    if (saveTimer > 0){
      saveTimer -= dt;
      if (saveTimer <= 0) saveAll();
    }
  }

  // --- Drawing ---
  function drawSky(t){
    // day/night cycle
    const cyc = (t*0.02) % 1; // slow
    const k = 0.5 - 0.5*Math.cos(cyc*Math.PI*2);
    const r1 = Math.floor(10 + 20*k);
    const g1 = Math.floor(20 + 40*k);
    const b1 = Math.floor(40 + 80*k);
    const r2 = Math.floor(5 + 10*k);
    const g2 = Math.floor(8 + 16*k);
    const b2 = Math.floor(18 + 38*k);
    const H = viewH || Math.floor(canvas.height / (viewDpr || 1));
    const W = viewW || Math.floor(canvas.width / (viewDpr || 1));
    const grad = ctx.createLinearGradient(0,0,0,H);
    grad.addColorStop(0, `rgb(${r1},${g1},${b1})`);
    grad.addColorStop(1, `rgb(${r2},${g2},${b2})`);
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,W,H);
  }

  function draw(){
    const W = viewW || Math.floor(canvas.width / (viewDpr || 1));
    const H = viewH || Math.floor(canvas.height / (viewDpr || 1));
    drawSky(now()/1000);

    camX = player.x + player.w*0.5 - W*0.5;
    camY = player.y + player.h*0.5 - H*0.52;
    camX = clamp(camX, 0, Math.max(0, WORLD_W*TILE - W));
    camY = clamp(camY, 0, Math.max(0, WORLD_H*TILE - H));

    // visible tiles
    const x0 = Math.floor(camX / TILE) - 1;
    const y0 = Math.floor(camY / TILE) - 1;
    const x1 = Math.floor((camX + W) / TILE) + 1;
    const y1 = Math.floor((camY + H) / TILE) + 1;

    for (let y=y0;y<=y1;y++){
      for (let x=x0;x<=x1;x++){
        const t = getTile(x,y);
        if (t === AIR) continue;
        const sx = x*TILE - camX;
        const sy = y*TILE - camY;
        // tile body
        if (t === LEAF){
          ctx.fillStyle = 'rgba(30,188,85,0.82)';
          ctx.fillRect(sx, sy, TILE, TILE);
          ctx.fillStyle = 'rgba(0,0,0,0.12)';
          ctx.fillRect(sx, sy, TILE, 4);
        } else {
          ctx.fillStyle = colors[t] || '#fff';
          ctx.fillRect(sx, sy, TILE, TILE);
          // simple shading
          ctx.fillStyle = 'rgba(255,255,255,0.10)';
          ctx.fillRect(sx, sy, TILE, 4);
          ctx.fillStyle = 'rgba(0,0,0,0.14)';
          ctx.fillRect(sx, sy+TILE-4, TILE, 4);
          ctx.fillStyle = 'rgba(0,0,0,0.10)';
          ctx.fillRect(sx+TILE-4, sy, 4, TILE);
        }
      }
    }

    // target block highlight
    const b = frontBlock();
    const t = getTile(b.x, b.y);
    const hx = b.x*TILE - camX;
    const hy = b.y*TILE - camY;
    ctx.strokeStyle = (mineHold ? 'rgba(255,216,77,0.95)' : 'rgba(242,246,255,0.70)');
    ctx.lineWidth = 2;
    ctx.strokeRect(hx+1, hy+1, TILE-2, TILE-2);
    ctx.lineWidth = 1;
    if (mineHold && mineTarget && mineTarget.x === b.x && mineTarget.y === b.y){
      const p = clamp(mineProg, 0, 1);
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(hx+4, hy+TILE-8, TILE-8, 4);
      ctx.fillStyle = 'rgba(255,216,77,0.85)';
      ctx.fillRect(hx+4, hy+TILE-8, (TILE-8)*p, 4);
    }

    // player (blocky)
    const px = player.x - camX;
    const py = player.y - camY;
    ctx.shadowColor = 'rgba(34,255,182,0.25)';
    ctx.shadowBlur = 12;
    ctx.fillStyle = '#22ffb6';
    ctx.fillRect(px, py, player.w, player.h);
    ctx.shadowBlur = 0;
    // face
    ctx.fillStyle = 'rgba(0,0,0,0.22)';
    const eyeY = py + player.h*0.28;
    const eyeX = player.face > 0 ? (px + player.w*0.62) : (px + player.w*0.22);
    ctx.fillRect(eyeX, eyeY, 5, 5);
    // legs shadow
    ctx.fillStyle = 'rgba(0,0,0,0.22)';
    ctx.fillRect(px+2, py+player.h-4, player.w-4, 3);

    // HUD
    ctx.fillStyle = 'rgba(0,0,0,0.32)';
    ctx.fillRect(10, 10, Math.min(520, W-20), 72);
    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    ctx.font = '900 14px Verdana';
    ctx.fillText('MiniCraft', 18, 32);
    ctx.fillStyle = 'rgba(242,246,255,0.80)';
    ctx.font = '900 12px Verdana';
    ctx.fillText(`Hold E / MINE to break • Q / tap PLACE to place • Target: ${tileName[t]}`, 18, 52);
    ctx.fillText(`Inventory: Dirt ${inv.dirt}  Stone ${inv.stone}  Wood ${inv.wood}  Leaf ${inv.leaf}`, 18, 70);

    // Hotbar
    const hbY = H - 64;
    const hbX = Math.floor(W*0.5 - 5*48*0.5);
    for (let i=0;i<5;i++){
      const x = hbX + i*48;
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(x, hbY, 44, 44);
      if (i === inv.sel){
        ctx.strokeStyle = 'rgba(34,255,182,0.95)';
        ctx.lineWidth = 3;
        ctx.strokeRect(x+1, hbY+1, 42, 42);
        ctx.lineWidth = 1;
      } else {
        ctx.strokeStyle = 'rgba(255,255,255,0.14)';
        ctx.strokeRect(x+1, hbY+1, 42, 42);
      }
      const tt = (i===0?DIRT:(i===1?STONE:(i===2?WOOD:(i===3?LEAF:AIR))));
      if (tt !== AIR){
        ctx.fillStyle = colors[tt];
        ctx.fillRect(x+10, hbY+10, 24, 24);
      } else {
        ctx.fillStyle = 'rgba(255,255,255,0.55)';
        ctx.font = '1000 12px Verdana';
        ctx.fillText('HAND', x+5, hbY+26);
      }
      ctx.fillStyle = 'rgba(242,246,255,0.78)';
      ctx.font = '900 11px Verdana';
      ctx.fillText(String(i+1), x+3, hbY+42);
    }
  }

  // Tap hotbar select
  canvas.addEventListener('pointerdown', (e) => {
    if (!running) return;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left);
    const y = (e.clientY - rect.top);
    const W = viewW || rect.width, H = viewH || rect.height;
    const hbY = H - 64;
    const hbX = Math.floor(W*0.5 - 5*48*0.5);
    if (y >= hbY && y <= hbY + 44){
      e.preventDefault();
      e.stopPropagation();
      for (let i=0;i<5;i++){
        const bx = hbX + i*48;
        if (x >= bx && x <= bx+44){
          inv.sel = i;
          return;
        }
      }
    }
  }, { passive:false });

  // --- Game loop ---
  let running = false;
  let lastT = 0;

  function start(){
    // seed
    seedStr = localStorage.getItem(LS.seed) || ('seed-' + Math.floor(Math.random()*1e9));
    rng = seeded(hashSeed(seedStr));
    genWorld();
    loadInv();

    // spawn near surface
    let sx = 12;
    for (let x=10;x<WORLD_W-10;x++){
      const y = findSurfaceY(x);
      if (y > 6 && y < WORLD_H-6){ sx = x; break; }
    }
    player.x = sx*TILE;
    player.y = (findSurfaceY(sx)-2)*TILE;
    player.vx = 0; player.vy = 0;

    overlay.classList.add('hidden');
    running = true;
    lastT = 0;
  }

  function findSurfaceY(x){
    for (let y=0;y<WORLD_H;y++){
      const t = getTile(x,y);
      if (t !== AIR && t !== LEAF) return y;
    }
    return WORLD_H-1;
  }

  btnPlay.addEventListener('pointerdown', (e) => { e.preventDefault(); start(); }, { passive:false });
  btnReset.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    if (!confirm('Reset MiniCraft save?')) return;
    resetSave();
    location.reload();
  }, { passive:false });

  function frame(t){
    requestAnimationFrame(frame);
    if (!running){
      draw();
      return;
    }
    if (!lastT) lastT = t;
    const dt = Math.min(0.04, (t - lastT) / 1000);
    lastT = t;

    moveAndCollide(dt);
    if (mineHold) tryMine(dt);
    saveTick(dt);

    draw();
  }
  requestAnimationFrame(frame);

})();
</script>
</body>
</html>


