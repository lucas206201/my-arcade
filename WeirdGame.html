<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>WEIRD GAME!!! (Reality Glitch)</title>
  <style>
    :root{
      --bg:#070914;
      --panel:rgba(255,255,255,0.08);
      --border:rgba(255,255,255,0.14);
      --text:#f2f6ff;
      --muted:rgba(242,246,255,0.75);
      --acid:#22ffb6;
      --danger:#ff4d6d;
      --sun:#ffd84d;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      display:flex;
      justify-content:center;
      align-items:center;
      background:
        radial-gradient(900px 700px at 50% 30%, rgba(34,255,182,0.14) 0%, rgba(7,9,20,0) 55%),
        radial-gradient(1000px 800px at 20% 90%, rgba(255,77,109,0.12) 0%, rgba(7,9,20,0) 60%),
        radial-gradient(1200px 900px at 85% 80%, rgba(255,216,77,0.10) 0%, rgba(7,9,20,0) 55%),
        var(--bg);
      color:var(--text);
      font-family: Verdana, "Comic Sans MS", system-ui, sans-serif;
      overflow:hidden;
      touch-action:none;
    }
    .wrap{
      width:min(1040px, 96vw);
      display:grid;
      grid-template-columns:1fr 320px;
      gap:14px;
      align-items:start;
    }
    @media (max-width: 980px){ .wrap{grid-template-columns:1fr} }
    .card{
      position:relative;
      border-radius:16px;
      background:linear-gradient(180deg, var(--panel), rgba(255,255,255,0.03));
      border:1px solid var(--border);
      box-shadow:0 24px 80px rgba(0,0,0,0.45);
      overflow:hidden;
    }
    canvas{
      display:block;
      width:100%;
      height:auto;
      background:radial-gradient(1200px 700px at 50% 25%, #15204a 0%, #0a0d20 55%, #070914 100%);
    }
    .side{
      padding:14px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .hud{
      background:rgba(0,0,0,0.28);
      border:1px solid var(--border);
      border-radius:14px;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-weight:900;
    }
    .pill{
      padding:6px 10px;
      border-radius:999px;
      background:rgba(0,0,0,0.35);
      border:1px solid rgba(255,255,255,0.14);
      color:var(--text);
      min-width:140px;
      text-align:center;
      font-weight:900;
    }
    .help{
      font-size:13px;
      line-height:1.4;
      color:var(--muted);
    }
    .btnRow{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:10px;
    }
    button{
      border:0;
      border-radius:14px;
      padding:12px 12px;
      cursor:pointer;
      font: inherit;
      font-weight:900;
      color:#071019;
      background:linear-gradient(45deg, var(--acid), #5bf7ff);
      box-shadow: 0 10px 20px rgba(0,0,0,0.25);
      transition: transform .08s ease;
      user-select:none;
    }
    button:active{transform:scale(0.98)}
    button.secondary{background:linear-gradient(45deg, var(--sun), #ffae4d)}
    button.danger{background:linear-gradient(45deg, var(--danger), #ffae4d)}
    .overlay{
      position:absolute;
      inset:0;
      background:rgba(0,0,0,0.80);
      display:flex;
      justify-content:center;
      align-items:center;
      padding:16px;
    }
    .overlay.hidden{display:none}
    .panel{
      width:min(620px, 92%);
      background:linear-gradient(180deg, rgba(255,255,255,0.09), rgba(0,0,0,0.55));
      border:1px solid var(--border);
      border-radius:18px;
      padding:18px;
      box-shadow:0 30px 110px rgba(0,0,0,0.55);
      text-align:center;
    }
    .panel h1{
      margin:0 0 8px 0;
      font-size:34px;
      letter-spacing:0.8px;
      color:#eaffff;
      text-shadow:0 0 18px rgba(34,255,182,0.32);
    }
    .panel p{ margin: 8px 0 14px 0; font-size:14px; color:var(--muted); }
    .kbd{
      display:inline-block;
      padding:2px 6px;
      border-radius:6px;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(0,0,0,0.35);
      font-weight:900;
      margin:0 2px;
      color:var(--text);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <canvas id="c" width="900" height="600"></canvas>
      <div class="overlay" id="overlay">
        <div class="panel">
          <h1 id="ovTitle">WEIRD GAME!!!</h1>
          <p id="ovText">
            The rules change every few seconds. Collect <b>glow orbs</b>. Avoid <b>void donuts</b>.
          </p>
          <p>
            Controls: <span class="kbd">WASD</span> or <span class="kbd">Arrow Keys</span>.
            Touch: drag anywhere.
          </p>
          <div class="btnRow" style="margin-top:10px">
            <button id="btnPlay">PLAY</button>
            <button class="secondary" id="btnHow">WHAT??</button>
          </div>
          <p class="help" id="how" style="display:none;margin-top:10px">
            Weirdness includes: gravity rotates, controls swap, colors invert, time hiccups, screen shakes.
            Your job is simple: <b>collect orbs</b> and survive as long as possible.
          </p>
        </div>
      </div>
    </div>

    <div class="card side">
      <div class="hud">
        <div class="row"><span>Score</span><span class="pill" id="score">0</span></div>
        <div class="row"><span>Weird</span><span class="pill" id="weird">0%</span></div>
        <div class="row"><span>Rule</span><span class="pill" id="rule">Ready</span></div>
        <div class="row"><span>Time</span><span class="pill" id="time">0:00</span></div>
        <div class="btnRow">
          <button class="secondary" id="btnPause">Pause</button>
          <button class="danger" id="btnRestart">Restart</button>
        </div>
      </div>
      <div class="help">
        Teaching note: this is a tiny physics sandbox with a “rule engine”.
        Every rule modifies how inputs and forces work.
      </div>
      <div class="help" style="opacity:0.95">
        Tip: If controls flip, follow the <b>trail</b> of your player dot.
      </div>
    </div>
  </div>

<script>
/**
 * WEIRD GAME!!! — Reality Glitch
 * Single-file canvas game.
 *
 * The core idea:
 * - A player dot moves with input and gravity.
 * - You collect orbs (+score) and avoid void donuts (damage).
 * - Every few seconds, a new "rule" applies (gravity rotates, controls invert, etc).
 *
 * Code is written to be teachable:
 * - update(): physics step
 * - resolve(): collisions
 * - ruleEngine(): applies weirdness modifiers
 */

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const weirdEl = document.getElementById('weird');
const ruleEl = document.getElementById('rule');
const timeEl = document.getElementById('time');

const overlay = document.getElementById('overlay');
const ovTitle = document.getElementById('ovTitle');
const ovText = document.getElementById('ovText');
const btnPlay = document.getElementById('btnPlay');
const btnHow = document.getElementById('btnHow');
const how = document.getElementById('how');
const btnPause = document.getElementById('btnPause');
const btnRestart = document.getElementById('btnRestart');

// --- Utility ---
const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
const rand = (a,b) => a + Math.random()*(b-a);
const now = () => performance.now();

function fmtTime(ms){
  const s = Math.floor(ms/1000);
  const m = Math.floor(s/60);
  const ss = String(s%60).padStart(2,'0');
  return `${m}:${ss}`;
}

function resize(){
  // Keep a friendly aspect ratio
  const maxW = Math.min(900, Math.floor(window.innerWidth * 0.96));
  const maxH = Math.min(600, Math.floor(window.innerHeight * 0.88));
  // Use 3:2 if possible
  let w = maxW;
  let h = Math.floor(w * 2/3);
  if (h > maxH){ h = maxH; w = Math.floor(h * 3/2); }
  canvas.width = Math.max(420, w);
  canvas.height = Math.max(280, h);
}
window.addEventListener('resize', resize);
resize();

// --- Input ---
const keys = new Set();
document.addEventListener('keydown', (e) => {
  if (e.key === ' ') e.preventDefault();
  keys.add(e.key);
});
document.addEventListener('keyup', (e) => keys.delete(e.key));

let touch = { active:false, x:0, y:0 };
canvas.addEventListener('pointerdown', (e) => {
  touch.active = true;
  const r = canvas.getBoundingClientRect();
  touch.x = (e.clientX - r.left) * (canvas.width / r.width);
  touch.y = (e.clientY - r.top) * (canvas.height / r.height);
});
canvas.addEventListener('pointermove', (e) => {
  if (!touch.active) return;
  const r = canvas.getBoundingClientRect();
  touch.x = (e.clientX - r.left) * (canvas.width / r.width);
  touch.y = (e.clientY - r.top) * (canvas.height / r.height);
});
window.addEventListener('pointerup', () => touch.active = false);

// --- Game objects ---
const player = {
  x: 0, y: 0,
  vx: 0, vy: 0,
  r: 14,
  hp: 3,
  trail: []
};

const orbs = [];
const voids = [];
const particles = [];

// --- Rule engine ---
const RULES = [
  { name: "Normal-ish", apply: (m) => m },
  { name: "Gravity: Down", apply: (m) => ({...m, gx:0, gy:1}) },
  { name: "Gravity: Up", apply: (m) => ({...m, gx:0, gy:-1}) },
  { name: "Gravity: Left", apply: (m) => ({...m, gx:-1, gy:0}) },
  { name: "Gravity: Right", apply: (m) => ({...m, gx:1, gy:0}) },
  { name: "Controls: Swapped (X<->Y)", apply: (m) => ({...m, swapXY:true}) },
  { name: "Controls: Inverted", apply: (m) => ({...m, invert:true}) },
  { name: "Low Friction (slippy)", apply: (m) => ({...m, drag:0.995}) },
  { name: "High Friction (sticky)", apply: (m) => ({...m, drag:0.88}) },
  { name: "Time Hiccup (stutter)", apply: (m) => ({...m, stutter:true}) },
  { name: "Colors Invert", apply: (m) => ({...m, invertColors:true}) },
  { name: "WOBBLE WORLD", apply: (m) => ({...m, wobble:true}) },
];

let ruleIdx = 0;
let ruleUntil = 0;

// Modifiers default
function baseMods(){
  return {
    gx: 0, gy: 1,            // gravity direction (unit vector)
    g: 680,                  // gravity strength
    accel: 1600,             // input acceleration
    drag: 0.93,              // velocity damping per second-ish (we'll adjust with dt)
    swapXY: false,
    invert: false,
    stutter: false,
    invertColors: false,
    wobble: false
  };
}

let mods = baseMods();
let weirdness = 0; // 0..1
let shake = 0;

// --- Game state ---
let running = false;
let paused = false;
let gameOver = false;
let score = 0;
let startTime = 0;
let lastT = 0;

function resetGame(){
  score = 0;
  weirdness = 0;
  shake = 0;
  player.x = canvas.width * 0.28;
  player.y = canvas.height * 0.55;
  player.vx = 0;
  player.vy = 0;
  player.hp = 3;
  player.trail = [];
  orbs.length = 0;
  voids.length = 0;
  particles.length = 0;
  ruleIdx = 0;
  mods = baseMods();
  ruleUntil = 0;
  paused = false;
  gameOver = false;
  btnPause.textContent = "Pause";
  scoreEl.textContent = "0";
  weirdEl.textContent = "0%";
  ruleEl.textContent = "Ready";
  timeEl.textContent = "0:00";
}

function start(){
  resetGame();
  running = true;
  startTime = now();
  lastT = 0;
  overlay.classList.add('hidden');
}

function endGame(){
  gameOver = true;
  paused = false;
  ovTitle.textContent = "YOU GOT TOO WEIRD";
  ovText.innerHTML = `Final score: <b>${score}</b><br/>The void donuts won this time.`;
  btnPlay.textContent = "Play Again";
  overlay.classList.remove('hidden');
}

btnPlay.addEventListener('click', start);
btnHow.addEventListener('click', () => how.style.display = (how.style.display === 'none') ? 'block' : 'none');
btnRestart.addEventListener('click', () => { if (running) start(); });
btnPause.addEventListener('click', () => {
  if (!running) return;
  if (gameOver) return;
  paused = !paused;
  btnPause.textContent = paused ? "Resume" : "Pause";
});

// --- Spawning ---
function spawnOrb(){
  orbs.push({
    x: rand(canvas.width * 0.25, canvas.width * 0.95),
    y: rand(canvas.height * 0.10, canvas.height * 0.90),
    r: rand(10, 16),
    t: rand(0, Math.PI*2),
    value: 10 + Math.floor(rand(0, 6)) * 5
  });
}

function spawnVoid(){
  voids.push({
    x: rand(canvas.width * 0.35, canvas.width * 0.95),
    y: rand(canvas.height * 0.12, canvas.height * 0.92),
    r: rand(18, 30),
    ring: rand(6, 10),
    t: rand(0, Math.PI*2),
    vx: rand(-40, 40),
    vy: rand(-40, 40)
  });
}

function burst(x,y, col, n=16){
  for (let i=0;i<n;i++){
    particles.push({
      x,y,
      vx: rand(-220, 220),
      vy: rand(-260, 260),
      life: rand(0.35, 0.9),
      r: rand(2, 5),
      col
    });
  }
}

// --- Collision helpers ---
function dist2(ax,ay,bx,by){
  const dx = ax - bx, dy = ay - by;
  return dx*dx + dy*dy;
}

// --- Rule switching ---
function pickNextRule(){
  // Get weirder over time by weighting away from Normal-ish.
  let idx = Math.floor(rand(0, RULES.length));
  if (weirdness < 0.25 && Math.random() < 0.35) idx = 0;
  if (weirdness > 0.55 && Math.random() < 0.25) idx = Math.floor(rand(2, RULES.length));
  ruleIdx = idx;
  mods = RULES[ruleIdx].apply(baseMods());
  // Rule duration shrinks as weirdness grows
  const dur = clamp(5.5 - weirdness * 3.0, 2.2, 5.5);
  ruleUntil = now() + dur * 1000;
  ruleEl.textContent = RULES[ruleIdx].name;
}

// --- Main loop ---
function update(dt){
  // Stutter rule: sometimes skip physics (feels glitchy)
  if (mods.stutter && Math.random() < 0.20){
    // Still let particles fade
    dt *= 0.15;
  }

  // Increase weirdness over time
  weirdness = clamp(weirdness + dt * 0.015, 0, 1);
  weirdEl.textContent = `${Math.floor(weirdness * 100)}%`;

  // Change rule
  if (now() > ruleUntil){
    pickNextRule();
    shake = Math.max(shake, 6 + weirdness * 10);
  }

  // Spawn things (more as it gets weirder)
  if (orbs.length < 4) spawnOrb();
  if (voids.length < 1 + Math.floor(weirdness * 3) && Math.random() < 0.015 + weirdness * 0.02) spawnVoid();
  if (Math.random() < 0.01) spawnOrb();

  // Input -> acceleration
  let ix = 0, iy = 0;
  const left = keys.has('ArrowLeft') || keys.has('a') || keys.has('A');
  const right = keys.has('ArrowRight') || keys.has('d') || keys.has('D');
  const up = keys.has('ArrowUp') || keys.has('w') || keys.has('W');
  const down = keys.has('ArrowDown') || keys.has('s') || keys.has('S');
  if (left) ix -= 1;
  if (right) ix += 1;
  if (up) iy -= 1;
  if (down) iy += 1;

  // Touch: steer toward finger
  if (touch.active){
    const dx = touch.x - player.x;
    const dy = touch.y - player.y;
    const m = Math.hypot(dx,dy) || 1;
    ix += dx / m;
    iy += dy / m;
  }

  // Apply modifier to controls
  if (mods.swapXY){ const t = ix; ix = iy; iy = t; }
  if (mods.invert){ ix *= -1; iy *= -1; }

  // Normalize diagonal input
  const im = Math.hypot(ix,iy);
  if (im > 1){ ix /= im; iy /= im; }

  // Gravity direction can wobble
  let gx = mods.gx, gy = mods.gy;
  if (mods.wobble){
    const a = Math.sin(now() * 0.002) * (0.35 + weirdness * 0.35);
    const ca = Math.cos(a), sa = Math.sin(a);
    const nx = gx * ca - gy * sa;
    const ny = gx * sa + gy * ca;
    gx = nx; gy = ny;
  }

  // Physics integrate
  player.vx += ix * mods.accel * dt;
  player.vy += iy * mods.accel * dt;
  player.vx += gx * mods.g * dt;
  player.vy += gy * mods.g * dt;

  // Drag: convert "per second-ish" into dt scaling
  const drag = Math.pow(mods.drag, dt * 60);
  player.vx *= drag;
  player.vy *= drag;

  player.x += player.vx * dt;
  player.y += player.vy * dt;

  // Walls (bounce)
  const bounce = 0.68;
  if (player.x < player.r){ player.x = player.r; player.vx = Math.abs(player.vx) * bounce; shake = Math.max(shake, 2); }
  if (player.x > canvas.width - player.r){ player.x = canvas.width - player.r; player.vx = -Math.abs(player.vx) * bounce; shake = Math.max(shake, 2); }
  if (player.y < player.r){ player.y = player.r; player.vy = Math.abs(player.vy) * bounce; shake = Math.max(shake, 2); }
  if (player.y > canvas.height - player.r){ player.y = canvas.height - player.r; player.vy = -Math.abs(player.vy) * bounce; shake = Math.max(shake, 2); }

  // Trail
  player.trail.push({x:player.x, y:player.y, life:0.35});
  if (player.trail.length > 90) player.trail.shift();
  for (const t of player.trail) t.life -= dt;
  while (player.trail.length && player.trail[0].life <= 0) player.trail.shift();

  // Move voids
  for (const v of voids){
    v.t += dt * (0.8 + weirdness * 1.4);
    v.x += v.vx * dt;
    v.y += v.vy * dt;
    // bounce softly
    if (v.x < v.r + 40 || v.x > canvas.width - v.r){ v.vx *= -1; }
    if (v.y < v.r + 20 || v.y > canvas.height - v.r){ v.vy *= -1; }
  }

  // Orbs float
  for (const o of orbs){
    o.t += dt * 2.2;
    o.y += Math.sin(o.t) * dt * 22;
  }

  // Collect orbs
  for (let i=orbs.length-1;i>=0;i--){
    const o = orbs[i];
    if (dist2(player.x, player.y, o.x, o.y) <= (player.r + o.r) * (player.r + o.r)){
      score += o.value;
      scoreEl.textContent = String(score);
      burst(o.x, o.y, '#22ffb6', 20);
      orbs.splice(i, 1);
      // Getting points makes the world slightly weirder
      weirdness = clamp(weirdness + 0.03, 0, 1);
      shake = Math.max(shake, 6);
    }
  }

  // Hit void donuts (damage)
  for (let i=voids.length-1;i>=0;i--){
    const v = voids[i];
    const d = Math.sqrt(dist2(player.x, player.y, v.x, v.y));
    // Donut: ring collision, not center. This is the "weird" part.
    const ringR = v.r;
    const ringW = v.ring;
    const inRing = d > ringR - ringW && d < ringR + ringW;
    if (inRing){
      // knockback away from donut center
      const nx = (player.x - v.x) / (d || 1);
      const ny = (player.y - v.y) / (d || 1);
      player.vx += nx * (520 + weirdness*520);
      player.vy += ny * (520 + weirdness*520);
      burst(player.x, player.y, '#ff4d6d', 26);
      shake = Math.max(shake, 14);
      player.hp -= 1;
      voids.splice(i, 1);
      if (player.hp <= 0){
        endGame();
        return;
      }
      break;
    }
  }

  // Particles
  for (let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.life -= dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vx *= Math.pow(0.90, dt*60);
    p.vy *= Math.pow(0.90, dt*60);
    if (p.life <= 0) particles.splice(i,1);
  }

  // Shake decay
  shake *= Math.pow(0.82, dt*60);
  if (shake < 0.1) shake = 0;
}

function draw(){
  // Optional color inversion (weird!)
  if (mods.invertColors){
    ctx.filter = 'invert(1) hue-rotate(140deg) saturate(1.4)';
  } else {
    ctx.filter = 'none';
  }

  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Screen shake
  ctx.save();
  if (shake > 0){
    const dx = (Math.random() - 0.5) * shake * 2;
    const dy = (Math.random() - 0.5) * shake * 2;
    ctx.translate(dx, dy);
  }

  // Star doodles
  ctx.globalAlpha = 0.5;
  for (let i=0;i<12;i++){
    const x = (i*97 + (now()*0.02)) % canvas.width;
    const y = (i*53 + 70) % canvas.height;
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.beginPath();
    ctx.arc(x, y, 1.6, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Vignette
  const g = ctx.createRadialGradient(canvas.width*0.5, canvas.height*0.45, 20, canvas.width*0.5, canvas.height*0.45, canvas.width*0.72);
  g.addColorStop(0, 'rgba(255,255,255,0.00)');
  g.addColorStop(1, 'rgba(0,0,0,0.50)');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // Voids
  for (const v of voids){
    const pulse = 1 + Math.sin(v.t*3) * 0.08;
    ctx.shadowColor = '#ff4d6d';
    ctx.shadowBlur = 18;
    ctx.strokeStyle = 'rgba(255,77,109,0.70)';
    ctx.lineWidth = 10;
    ctx.beginPath();
    ctx.arc(v.x, v.y, v.r * pulse, 0, Math.PI*2);
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Donut hole
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    ctx.beginPath();
    ctx.arc(v.x, v.y, (v.r - v.ring) * pulse, 0, Math.PI*2);
    ctx.fill();
  }

  // Orbs
  for (const o of orbs){
    const glow = 14 + Math.sin(o.t*2) * 4;
    ctx.shadowColor = '#22ffb6';
    ctx.shadowBlur = glow;
    ctx.fillStyle = '#22ffb6';
    ctx.beginPath();
    ctx.arc(o.x, o.y, o.r, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;
    // highlight
    ctx.fillStyle = 'rgba(255,255,255,0.55)';
    ctx.beginPath();
    ctx.arc(o.x - o.r*0.35, o.y - o.r*0.35, o.r*0.25, 0, Math.PI*2);
    ctx.fill();
  }

  // Particles
  for (const p of particles){
    ctx.globalAlpha = clamp(p.life / 0.9, 0, 1);
    ctx.fillStyle = p.col;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Trail
  for (const t of player.trail){
    ctx.globalAlpha = clamp(t.life / 0.35, 0, 1) * 0.45;
    ctx.fillStyle = '#5bf7ff';
    ctx.beginPath();
    ctx.arc(t.x, t.y, 6, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Player
  ctx.shadowColor = '#ffd84d';
  ctx.shadowBlur = 18;
  ctx.fillStyle = '#ffd84d';
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.r, 0, Math.PI*2);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Player face (tiny)
  ctx.fillStyle = 'rgba(0,0,0,0.30)';
  ctx.beginPath();
  ctx.arc(player.x - 4, player.y - 3, 2, 0, Math.PI*2);
  ctx.arc(player.x + 4, player.y - 3, 2, 0, Math.PI*2);
  ctx.fill();
  ctx.strokeStyle = 'rgba(0,0,0,0.25)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(player.x, player.y + 4, 5, 0, Math.PI);
  ctx.stroke();

  // HP hearts
  for (let i=0;i<3;i++){
    const x = 16 + i*24;
    const y = 22;
    const alive = i < player.hp;
    ctx.globalAlpha = alive ? 1 : 0.22;
    drawHeart(x, y, 9, alive ? '#ff4d6d' : '#ff4d6d');
  }
  ctx.globalAlpha = 1;

  // Mini rule hint arrow for gravity direction
  drawGravityArrow(mods.gx, mods.gy);

  ctx.restore();

  // Update time UI
  if (running && !paused && !gameOver){
    timeEl.textContent = fmtTime(now() - startTime);
  }
}

function drawHeart(x, y, s, col){
  ctx.fillStyle = col;
  ctx.beginPath();
  ctx.moveTo(x, y + s*0.25);
  ctx.bezierCurveTo(x - s, y - s*0.25, x - s, y + s*0.85, x, y + s*1.1);
  ctx.bezierCurveTo(x + s, y + s*0.85, x + s, y - s*0.25, x, y + s*0.25);
  ctx.fill();
}

function drawGravityArrow(gx,gy){
  // Show what "down" means right now (useful when gravity rotates)
  const cx = canvas.width - 60;
  const cy = 34;
  const len = 18;
  const m = Math.hypot(gx,gy) || 1;
  const ux = gx/m, uy = gy/m;
  ctx.strokeStyle = 'rgba(255,255,255,0.55)';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(cx, cy, 20, 0, Math.PI*2);
  ctx.stroke();
  ctx.strokeStyle = '#22ffb6';
  ctx.beginPath();
  ctx.moveTo(cx, cy);
  ctx.lineTo(cx + ux*len, cy + uy*len);
  ctx.stroke();
  // arrow head
  ctx.fillStyle = '#22ffb6';
  const ax = cx + ux*len;
  const ay = cy + uy*len;
  ctx.beginPath();
  ctx.arc(ax, ay, 4, 0, Math.PI*2);
  ctx.fill();
}

function frame(t){
  requestAnimationFrame(frame);
  if (!running) return;
  if (paused || gameOver){
    draw();
    return;
  }
  if (!lastT) lastT = t;
  const dt = Math.min(0.033, (t - lastT) / 1000);
  lastT = t;
  update(dt);
  draw();
}
requestAnimationFrame(frame);

// Start screen text
ruleEl.textContent = "Ready";

</script>
</body>
</html>


