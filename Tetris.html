<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Kid's Neon Tetris</title>
    <style>
        /* General Page Styling */
        body {
            background-color: #1a1a2e; /* Dark Blue/Black background */
            color: white;
            font-family: 'Verdana', 'Comic Sans MS', sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden; /* Prevent scrolling on mobile */
            touch-action: none; /* Prevent zoom/scroll gestures */
        }

        h1 {
            margin: 10px 0;
            text-shadow: 2px 2px 4px #000;
            color: #ff00de; /* Vibrant pink title */
        }

        /* Game Container Layout */
        #game-container {
            position: relative;
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            gap: 20px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        /* The Canvas */
        canvas {
            border: 4px solid #333;
            border-radius: 5px;
            background-color: #0d0d16;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
            touch-action: none; /* allow swipes/taps without page scrolling */
        }

        /* Sidebar for Score/Level */
        #sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 120px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid #444;
        }

        .stat-label {
            font-size: 0.9em;
            color: #aaa;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #00ffff;
        }

        /* Overlay (Start / Game Over) */
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 15px;
            z-index: 10;
        }

        .hidden {
            display: none !important;
        }

        #overlay h2 {
            font-size: 3em;
            color: #ffff00;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff0000;
        }

        button.start-btn {
            padding: 15px 40px;
            font-size: 1.5em;
            font-family: inherit;
            font-weight: bold;
            color: white;
            background: linear-gradient(45deg, #ff00de, #00ffff);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 0 15px #ff00de;
            transition: transform 0.1s;
        }

        button.start-btn:active {
            transform: scale(0.95);
        }

        /* On-Screen Controls */
        #controls {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            width: 100%;
            max-width: min(420px, 92vw);
        }

        .control-btn {
            background: #333;
            border: 2px solid #555;
            color: white;
            font-size: clamp(18px, 4.2vw, 26px);
            padding: clamp(14px, 3.6vw, 18px);
            border-radius: 10px;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation; /* Optimizes for touch */
        }
        
        .control-btn:active {
            background: #555;
        }

        /* Specific grid layout for controls */
        #btn-up { grid-column: 2; background-color: #be00be; } /* Rotate */
        #btn-left { grid-column: 1; grid-row: 2; background-color: #0066ff; }
        #btn-down { grid-column: 2; grid-row: 2; background-color: #ff7f00; } /* Soft Drop */
        #btn-right { grid-column: 3; grid-row: 2; background-color: #0066ff; }
        #btn-drop { grid-column: 1 / span 3; grid-row: 3; background-color: #ff0000; font-size: clamp(14px, 3.5vw, 18px); text-transform: uppercase; font-weight: bold; } /* Hard Drop */

        /* Mobile Layout Adjustments */
        @media (max-width: 600px) {
            #game-container {
                flex-direction: column;
                align-items: center;
                gap: 10px;
            }
            #sidebar {
                flex-direction: row;
                width: 100%;
                justify-content: space-around;
                min-width: auto;
            }
            canvas {
                /* Scale canvas down slightly on small screens if needed, 
                   but 300px width usually fits most phones */
                max-width: 90vw;
            }
        }
    </style>
</head>
<body>

    <h1>NEON TETRIS</h1>

    <div id="game-container">
        <!-- The Game Board -->
        <canvas id="tetris" width="300" height="600"></canvas>

        <!-- Sidebar Info -->
        <div id="sidebar">
            <div class="stat-box">
                <div class="stat-label">Score</div>
                <div id="score" class="stat-value">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Level</div>
                <div id="level" class="stat-value">1</div>
            </div>
            <div class="stat-box" style="display:none;"> <!-- Hidden for simplicity, could be Next Piece -->
                <div class="stat-label">Lines</div>
                <div id="lines" class="stat-value">0</div>
            </div>
        </div>

        <!-- Start / Game Over Overlay -->
        <div id="overlay">
            <h2 id="overlay-title">TETRIS</h2>
            <button id="start-btn" class="start-btn">PLAY</button>
        </div>
    </div>

    <!-- On-screen Controls -->
    <div id="controls">
        <button class="control-btn" id="btn-up">↻</button>
        <button class="control-btn" id="btn-left">←</button>
        <button class="control-btn" id="btn-down">↓</button>
        <button class="control-btn" id="btn-right">→</button>
        <button class="control-btn" id="btn-drop">HARD DROP</button>
    </div>

<script>
/**
 * TETRIS GAME LOGIC
 */

const canvas = document.getElementById('tetris');
const ctx = canvas.getContext('2d');
const scoreElement = document.getElementById('score');
const levelElement = document.getElementById('level');
const overlay = document.getElementById('overlay');
const overlayTitle = document.getElementById('overlay-title');
const startBtn = document.getElementById('start-btn');

// --- CONSTANTS ---
const ROW = 20;
const COL = 10;
let SQ = 30; // Square size in pixels (will be resized for phones)
const VACANT = "#0d0d16"; // Empty square color matches canvas background

// Define the Shapes (Tetriminos)
const PIECES = [
    [Z, "#ff0000"], // Red
    [S, "#00ff00"], // Green
    [T, "#be00be"], // Purple
    [O, "#ffff00"], // Yellow
    [L, "#ff7f00"], // Orange
    [I, "#00ffff"], // Cyan
    [J, "#0066ff"]  // Blue
];

// Shape Definitions (0 = empty, 1 = filled)
// Each subarray is a rotation state
const I_Piece = [
    [[0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0]],
    [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]],
    [[0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0]],
    [[0, 0, 0, 0], [0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0]]
];

const J_Piece = [
    [[1, 0, 0], [1, 1, 1], [0, 0, 0]],
    [[0, 1, 1], [0, 1, 0], [0, 1, 0]],
    [[0, 0, 0], [1, 1, 1], [0, 0, 1]],
    [[0, 1, 0], [0, 1, 0], [1, 1, 0]]
];

const L_Piece = [
    [[0, 0, 1], [1, 1, 1], [0, 0, 0]],
    [[0, 1, 0], [0, 1, 0], [0, 1, 1]],
    [[0, 0, 0], [1, 1, 1], [1, 0, 0]],
    [[1, 1, 0], [0, 1, 0], [0, 1, 0]]
];

const O_Piece = [
    [[0, 0, 0, 0], [0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]
];

const S_Piece = [
    [[0, 1, 1], [1, 1, 0], [0, 0, 0]],
    [[0, 1, 0], [0, 1, 1], [0, 0, 1]],
    [[0, 0, 0], [0, 1, 1], [1, 1, 0]],
    [[1, 0, 0], [1, 1, 0], [0, 1, 0]]
];

const T_Piece = [
    [[0, 1, 0], [1, 1, 1], [0, 0, 0]],
    [[0, 1, 0], [0, 1, 1], [0, 1, 0]],
    [[0, 0, 0], [1, 1, 1], [0, 1, 0]],
    [[0, 1, 0], [1, 1, 0], [0, 1, 0]]
];

const Z_Piece = [
    [[1, 1, 0], [0, 1, 1], [0, 0, 0]],
    [[0, 0, 1], [0, 1, 1], [0, 1, 0]],
    [[0, 0, 0], [1, 1, 0], [0, 1, 1]],
    [[0, 1, 0], [1, 1, 0], [1, 0, 0]]
];

function I(){ return I_Piece; }
function J(){ return J_Piece; }
function L(){ return L_Piece; }
function O(){ return O_Piece; }
function S(){ return S_Piece; }
function T(){ return T_Piece; }
function Z(){ return Z_Piece; }


// --- VARIABLES ---
let board = [];
let score = 0;
let level = 1;
let gameOver = false;
let dropStart = Date.now();
let dropInterval = 1000; // Initial speed (1 second per drop)
let animationId = null;
let currentPiece;

// Particle System
let particles = [];

// --- FUNCTIONS ---

// Responsive canvas sizing (important for phones)
function resizeCanvasToScreen() {
    // Choose a square size that fits the screen nicely.
    // We try to fit the board width inside the viewport, leaving room for borders + sidebar.
    const vw = Math.max(320, window.innerWidth);
    const vh = Math.max(420, window.innerHeight);

    // Approx available width for the board (on phone it's basically the full width)
    const maxBoardWidth = Math.min(vw * 0.92, 420);
    const maxBoardHeight = Math.min(vh * 0.70, 760);

    const sqFromW = Math.floor(maxBoardWidth / COL);
    const sqFromH = Math.floor(maxBoardHeight / ROW);
    SQ = clampInt(Math.min(sqFromW, sqFromH), 18, 34);

    canvas.width = COL * SQ;
    canvas.height = ROW * SQ;

    // Clear particles on resize to avoid odd pixel offsets
    particles = [];
}

function clampInt(v, lo, hi) {
    return Math.max(lo, Math.min(hi, v | 0));
}

// Initialize the board
function createBoard() {
    for(let r = 0; r < ROW; r++){
        board[r] = [];
        for(let c = 0; c < COL; c++){
            board[r][c] = VACANT;
        }
    }
}

// Draw a single square
function drawSquare(x, y, color, isGhost = false){
    ctx.fillStyle = color;
    
    if (isGhost) {
        // Ghost style: outline only or transparent fill
        ctx.globalAlpha = 0.2; // Transparent
        ctx.fillRect(x*SQ, y*SQ, SQ, SQ);
        ctx.globalAlpha = 1.0; // Reset
        ctx.strokeStyle = color;
        ctx.strokeRect(x*SQ, y*SQ, SQ, SQ);
    } else {
        // Solid block style
        ctx.fillRect(x*SQ, y*SQ, SQ, SQ);
        ctx.strokeStyle = "rgba(0,0,0,0.3)"; // Subtle border
        ctx.strokeRect(x*SQ, y*SQ, SQ, SQ);
        
        // Add a highlight for "pop" effect (bevel look)
        ctx.fillStyle = "rgba(255,255,255,0.3)";
        ctx.fillRect(x*SQ, y*SQ, SQ, 4); // Top highlight
        ctx.fillRect(x*SQ, y*SQ, 4, SQ); // Left highlight
    }
}

// Draw the board
function drawBoard(){
    for(let r = 0; r < ROW; r++){
        for(let c = 0; c < COL; c++){
            drawSquare(c, r, board[r][c]);
        }
    }
}

// THE PIECE OBJECT
class Piece {
    constructor(tetromino, color){
        this.tetromino = tetromino;
        this.color = color;
        
        this.tetrominoN = 0; // Starts from the first rotation pattern
        this.activeTetromino = this.tetromino[this.tetrominoN];
        
        // Start position
        this.x = 3;
        this.y = -2; // Start slightly above board
    }
    
    // Fill function
    fill(color, isGhost = false){
        for(let r = 0; r < this.activeTetromino.length; r++){
            for(let c = 0; c < this.activeTetromino.length; c++){
                // Draw only occupied squares
                if(this.activeTetromino[r][c]){
                    drawSquare(this.x + c, this.y + r, color, isGhost);
                }
            }
        }
    }
    
    // Draw piece
    draw(){
        this.fill(this.color);
    }
    
    // Undraw piece (for movement)
    unDraw(){
        this.fill(VACANT); // Technically we redraw the board every frame, but this logic helps conceptualize
    }
    
    // Move Down
    moveDown(){
        if(!this.collision(0, 1, this.activeTetromino)){
            this.y++;
        } else {
            // Collision detected - Lock the piece
            this.lock();
            currentPiece = randomPiece();
        }
    }
    
    // Move Right
    moveRight(){
        if(!this.collision(1, 0, this.activeTetromino)){
            this.x++;
        }
    }
    
    // Move Left
    moveLeft(){
        if(!this.collision(-1, 0, this.activeTetromino)){
            this.x--;
        }
    }
    
    // Rotate
    rotate(){
        let nextPattern = this.tetromino[(this.tetrominoN + 1) % this.tetromino.length];
        let kick = 0;
        
        // Basic wall kick check (if rotation puts piece out of bounds)
        if(this.collision(0, 0, nextPattern)){
            if(this.x > COL/2){
                // Right wall kick
                kick = -1; 
                if(this.collision(-1, 0, nextPattern)) kick = -2; // I piece needs more
            } else {
                // Left wall kick
                kick = 1;
                if(this.collision(1, 0, nextPattern)) kick = 2;
            }
        }
        
        if(!this.collision(kick, 0, nextPattern)){
            this.x += kick;
            this.tetrominoN = (this.tetrominoN + 1) % this.tetromino.length;
            this.activeTetromino = this.tetromino[this.tetrominoN];
        }
    }
    
    // Hard Drop
    hardDrop(){
        while(!this.collision(0, 1, this.activeTetromino)){
            this.y++;
        }
        this.lock();
        currentPiece = randomPiece();
    }
    
    // Collision Detection
    collision(x, y, piece){
        for(let r = 0; r < piece.length; r++){
            for(let c = 0; c < piece.length; c++){
                // If square is empty, skip
                if(!piece[r][c]){
                    continue;
                }
                
                // Coordinates of the piece after movement
                let newX = this.x + c + x;
                let newY = this.y + r + y;
                
                // Check boundaries
                if(newX < 0 || newX >= COL || newY >= ROW){
                    return true;
                }
                
                // Check if grid position is already taken (ignore negative Y (above board))
                if(newY < 0){
                    continue;
                }
                
                if(board[newY][newX] != VACANT){
                    return true;
                }
            }
        }
        return false;
    }
    
    // Lock piece into place
    lock(){
        for(let r = 0; r < this.activeTetromino.length; r++){
            for(let c = 0; c < this.activeTetromino.length; c++){
                if(!this.activeTetromino[r][c]){
                    continue;
                }
                // Game Over Logic
                if(this.y + r < 0){
                    gameOver = true;
                    showGameOver();
                    return;
                }
                // Lock into board
                board[this.y + r][this.x + c] = this.color;
            }
        }
        
        // Remove full lines
        for(let r = 0; r < ROW; r++){
            let isRowFull = true;
            for(let c = 0; c < COL; c++){
                if(board[r][c] == VACANT){
                    isRowFull = false;
                    break;
                }
            }
            if(isRowFull){
                // Move everything down
                createExplosion(r); // Visual effect
                for(let y = r; y > 1; y--){
                    for(let c = 0; c < COL; c++){
                        board[y][c] = board[y-1][c];
                    }
                }
                for(let c = 0; c < COL; c++){
                    board[0][c] = VACANT;
                }
                
                // Score Update
                score += 100;
                scoreElement.innerHTML = score;
                
                // Level Up every 500 points
                if(score % 500 === 0){
                    level++;
                    levelElement.innerHTML = level;
                    // Increase speed (decrease interval), cap at 200ms
                    dropInterval = Math.max(200, 1000 - (level * 100));
                }
            }
        }
    }
}

// Generate Random Piece
function randomPiece(){
    let r = Math.floor(Math.random() * PIECES.length);
    return new Piece(PIECES[r][0](), PIECES[r][1]);
}

// Ghost Piece
function drawGhost(){
    if(gameOver) return;
    
    let ghost = new Piece(currentPiece.tetromino, currentPiece.color);
    ghost.x = currentPiece.x;
    ghost.y = currentPiece.y;
    ghost.tetrominoN = currentPiece.tetrominoN;
    ghost.activeTetromino = currentPiece.activeTetromino;
    
    // Move ghost down until collision
    while(!ghost.collision(0, 1, ghost.activeTetromino)){
        ghost.y++;
    }
    
    ghost.fill(currentPiece.color, true); // True = isGhost
}

// --- PARTICLE EFFECTS ---
class Particle {
    constructor(x, y, color){
        this.x = x;
        this.y = y;
        this.color = color;
        this.size = Math.random() * 5 + 2;
        this.speedX = Math.random() * 4 - 2;
        this.speedY = Math.random() * 4 - 2;
        this.life = 100; // Frames to live
    }
    
    update(){
        this.x += this.speedX;
        this.y += this.speedY;
        this.life -= 2;
        this.size *= 0.95; // Shrink
    }
    
    draw(){
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
}

function createExplosion(row){
    // Create particles across the row
    for(let c = 0; c < COL; c++){
        // Generate a few particles per block
        for(let i = 0; i < 5; i++){
            let pX = (c * SQ) + (SQ / 2);
            let pY = (row * SQ) + (SQ / 2);
            let color = board[row][c];
            particles.push(new Particle(pX, pY, color));
        }
    }
}

function handleParticles(){
    for(let i = 0; i < particles.length; i++){
        particles[i].update();
        particles[i].draw();
        
        if(particles[i].life <= 0 || particles[i].size < 0.5){
            particles.splice(i, 1);
            i--;
        }
    }
}

// --- GAME LOOP ---

function draw(){
    // Clear canvas
    ctx.fillStyle = VACANT;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    drawBoard();
    drawGhost();
    currentPiece.draw();
    handleParticles();
}

function update(){
    if(gameOver) return;
    
    let now = Date.now();
    let delta = now - dropStart;
    
    if(delta > dropInterval){
        currentPiece.moveDown();
        dropStart = Date.now();
    }
    
    draw();
    animationId = requestAnimationFrame(update);
}

// --- GAME CONTROLS ---

function resetGame(){
    resizeCanvasToScreen();
    createBoard();
    score = 0;
    level = 1;
    dropInterval = 1000;
    scoreElement.innerHTML = score;
    levelElement.innerHTML = level;
    gameOver = false;
    currentPiece = randomPiece();
    particles = [];
}

function startGame(){
    resetGame();
    overlay.classList.add('hidden');
    dropStart = Date.now();
    if(animationId) cancelAnimationFrame(animationId);
    update();
}

function showGameOver(){
    cancelAnimationFrame(animationId);
    overlayTitle.innerText = "GAME OVER";
    startBtn.innerText = "Play Again";
    overlay.classList.remove('hidden');
}

startBtn.addEventListener('click', startGame);

// Keyboard Controls
document.addEventListener("keydown", function(event){
    if(gameOver || !overlay.classList.contains('hidden')) return; // Don't move if game over or paused/start screen

    if(event.keyCode == 37){
        currentPiece.moveLeft();
        dropStart = Date.now(); // Optional: delay drop when moving to help sliding
    } else if(event.keyCode == 38){
        currentPiece.rotate();
        dropStart = Date.now();
    } else if(event.keyCode == 39){
        currentPiece.moveRight();
        dropStart = Date.now();
    } else if(event.keyCode == 40){
        currentPiece.moveDown();
    } else if(event.keyCode == 32){ // Spacebar
        currentPiece.hardDrop();
    }
    
    // Redraw immediately for responsiveness
    draw();
});

// On-Screen Button Controls (Mouse/Touch)
const btnLeft = document.getElementById('btn-left');
const btnRight = document.getElementById('btn-right');
const btnUp = document.getElementById('btn-up');
const btnDown = document.getElementById('btn-down');
const btnDrop = document.getElementById('btn-drop');

function canInput(){
    return !(gameOver || !overlay.classList.contains('hidden'));
}

// Button press-and-hold support (great for phones)
function bindHoldButton(element, action, repeatMs = 110){
    let timer = null;
    const start = (e) => {
        e.preventDefault();
        if (!canInput()) return;
        action();
        draw();
        // repeat for movement/down
        if (repeatMs > 0){
            timer = setInterval(() => {
                if (!canInput()) return;
                action();
                draw();
            }, repeatMs);
        }
    };
    const stop = () => {
        if (timer) clearInterval(timer);
        timer = null;
    };
    element.addEventListener('pointerdown', start);
    element.addEventListener('pointerup', stop);
    element.addEventListener('pointercancel', stop);
    element.addEventListener('pointerleave', stop);
}

// Left/Right/Down repeat, Rotate and Hard Drop are single-tap
bindHoldButton(btnLeft, () => currentPiece.moveLeft(), 110);
bindHoldButton(btnRight, () => currentPiece.moveRight(), 110);
bindHoldButton(btnDown, () => currentPiece.moveDown(), 80);
bindHoldButton(btnUp, () => currentPiece.rotate(), 0);
bindHoldButton(btnDrop, () => currentPiece.hardDrop(), 0);

// Swipe controls on the canvas:
// - Tap: rotate
// - Swipe left/right: move
// - Swipe down: hard drop (big) or soft drop (small)
let swipeStart = null;
let activeTouchId = null;

function getCanvasPos(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    return {
        x: (clientX - rect.left) * (canvas.width / rect.width),
        y: (clientY - rect.top) * (canvas.height / rect.height),
    };
}

canvas.addEventListener('touchstart', (e) => {
    // Two-finger tap = hard drop
    if (!canInput()) return;
    if (e.touches && e.touches.length >= 2){
        e.preventDefault();
        currentPiece.hardDrop();
        draw();
        return;
    }
}, { passive:false });

canvas.addEventListener('pointerdown', (e) => {
    if (!canInput()) return;
    e.preventDefault();
    activeTouchId = e.pointerId;
    const p = getCanvasPos(e.clientX, e.clientY);
    swipeStart = { x: p.x, y: p.y, t: performance.now() };
});

canvas.addEventListener('pointerup', (e) => {
    if (e.pointerId !== activeTouchId) return;
    if (!canInput()) { swipeStart = null; return; }
    e.preventDefault();
    const p = getCanvasPos(e.clientX, e.clientY);
    const start = swipeStart;
    swipeStart = null;
    activeTouchId = null;
    if (!start) return;

    const dx = p.x - start.x;
    const dy = p.y - start.y;
    const dist = Math.hypot(dx, dy);
    const tapThreshold = Math.max(10, SQ * 0.35);
    const swipeThreshold = Math.max(18, SQ * 0.65);

    // Tap => rotate
    if (dist < tapThreshold){
        currentPiece.rotate();
        draw();
        return;
    }

    // Swipes
    if (Math.abs(dx) > Math.abs(dy)){
        // Horizontal
        if (Math.abs(dx) < swipeThreshold) return;
        if (dx > 0) currentPiece.moveRight();
        else currentPiece.moveLeft();
        draw();
        return;
    } else {
        // Vertical
        if (Math.abs(dy) < swipeThreshold) return;
        if (dy > 0){
            // Swipe down: big swipe = hard drop, small = soft drop a bit
            if (dy > SQ * 2.0) currentPiece.hardDrop();
            else currentPiece.moveDown();
        } else {
            // Swipe up: rotate (extra kid-friendly)
            currentPiece.rotate();
        }
        draw();
        return;
    }
});

// Keep canvas responsive on orientation changes
window.addEventListener('resize', () => {
    // Only resize when not actively playing to avoid surprising mid-piece scaling
    if (!overlay.classList.contains('hidden')) {
        resizeCanvasToScreen();
        drawBoard();
    }
});

// Initial Setup
resizeCanvasToScreen();
createBoard();
drawBoard(); // Draw empty board initially

</script>
</body>
</html>
