<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Mini Hole.io (Single File)</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:rgba(255,255,255,0.08);
      --border:rgba(255,255,255,0.14);
      --text:#f2f6ff;
      --muted:rgba(242,246,255,0.75);
      --accent:#22ffb6;
      --danger:#ff4d6d;
      --gold:#ffd84d;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      display:flex;
      justify-content:center;
      align-items:center;
      background:
        radial-gradient(900px 700px at 50% 25%, rgba(34,255,182,0.12) 0%, rgba(11,18,32,0) 60%),
        radial-gradient(900px 700px at 80% 80%, rgba(255,216,77,0.10) 0%, rgba(11,18,32,0) 60%),
        var(--bg);
      color:var(--text);
      font-family: Verdana, "Comic Sans MS", system-ui, sans-serif;
      overflow:hidden;
      touch-action:none;
    }
    .wrap{
      width:min(1200px, 96vw);
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:14px;
      align-items:start;
    }
    @media (max-width: 980px){ .wrap{grid-template-columns:1fr} }
    .card{
      position:relative;
      border-radius:16px;
      background:linear-gradient(180deg, var(--panel), rgba(255,255,255,0.03));
      border:1px solid var(--border);
      box-shadow:0 24px 80px rgba(0,0,0,0.45);
      overflow:hidden;
    }
    canvas{
      display:block;
      width:100%;
      height:auto;
      background:linear-gradient(180deg, #1b2a4e 0%, #0b1220 70%, #080c16 100%);
      touch-action:none;
    }
    .side{
      padding:14px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .hud{
      background:rgba(0,0,0,0.28);
      border:1px solid var(--border);
      border-radius:14px;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-weight:900;
    }
    .pill{
      padding:6px 10px;
      border-radius:999px;
      background:rgba(0,0,0,0.35);
      border:1px solid rgba(255,255,255,0.14);
      min-width:150px;
      text-align:center;
      font-weight:900;
    }
    .help{
      font-size:13px;
      line-height:1.4;
      color:var(--muted);
    }
    .btnRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    button{
      border:0;
      border-radius:14px;
      padding:12px 12px;
      cursor:pointer;
      font: inherit;
      font-weight:900;
      color:#071019;
      background:linear-gradient(45deg, var(--accent), #5bf7ff);
      box-shadow: 0 10px 20px rgba(0,0,0,0.25);
      transition: transform .08s ease;
      user-select:none;
    }
    button:active{transform:scale(0.98)}
    button.secondary{background:linear-gradient(45deg, var(--gold), #ffae4d)}
    button.danger{background:linear-gradient(45deg, var(--danger), #ffae4d)}
    .leader{
      background:rgba(0,0,0,0.28);
      border:1px solid var(--border);
      border-radius:14px;
      padding:12px;
    }
    .shop{
      background:rgba(0,0,0,0.28);
      border:1px solid var(--border);
      border-radius:14px;
      padding:12px;
    }
    .leader h3{
      margin:0 0 8px 0;
      font-size:14px;
      letter-spacing:0.5px;
      color:#eaffff;
    }
    .shop h3{
      margin:0 0 8px 0;
      font-size:14px;
      letter-spacing:0.5px;
      color:#eaffff;
    }
    .shopItem{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:8px 8px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.10);
      background:rgba(0,0,0,0.20);
      margin-bottom:8px;
      font-size:13px;
      font-weight:900;
    }
    .shopItem small{
      display:block;
      font-size:11px;
      font-weight:800;
      opacity:0.8;
      margin-top:2px;
    }
    .tag{
      display:inline-block;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.14);
      background:rgba(0,0,0,0.30);
      font-size:11px;
      font-weight:900;
      color:rgba(242,246,255,0.92);
      margin-left:8px;
    }
    .tag.locked{ color:rgba(255,77,109,0.95); }
    .tag.owned{ color:rgba(34,255,182,0.95); }
    .tinyBtn{
      padding:8px 10px;
      border-radius:12px;
      font-weight:900;
      min-width:92px;
    }
    .rank{
      display:flex;
      justify-content:space-between;
      gap:10px;
      padding:6px 8px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.10);
      background:rgba(0,0,0,0.20);
      margin-bottom:8px;
      font-size:13px;
      font-weight:800;
    }
    .dot{
      width:10px;height:10px;border-radius:50%;
      display:inline-block;
      margin-right:8px;
      vertical-align:middle;
      box-shadow:0 0 12px rgba(255,255,255,0.25);
    }
    .overlay{
      position:absolute;
      inset:0;
      background:rgba(0,0,0,0.82);
      display:flex;
      justify-content:center;
      align-items:center;
      padding:16px;
      z-index:10;
    }
    .overlay.hidden{display:none}
    .panel{
      width:min(620px, 92%);
      background:linear-gradient(180deg, rgba(255,255,255,0.09), rgba(0,0,0,0.55));
      border:1px solid var(--border);
      border-radius:18px;
      padding:18px;
      box-shadow:0 30px 110px rgba(0,0,0,0.55);
      text-align:center;
    }
    .panel h1{
      margin:0 0 8px 0;
      font-size:34px;
      letter-spacing:0.6px;
      color:#eaffff;
      text-shadow:0 0 18px rgba(34,255,182,0.30);
    }
    .panel p{ margin: 8px 0 14px 0; font-size:14px; color:var(--muted); }
    .kbd{
      display:inline-block;
      padding:2px 6px;
      border-radius:6px;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(0,0,0,0.35);
      font-weight:900;
      margin:0 2px;
      color:var(--text);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <canvas id="c" width="960" height="600"></canvas>
      <div class="overlay" id="overlay">
        <div class="panel">
          <h1 id="ovTitle">Mini Hole.io</h1>
          <p id="ovText">Move your hole, swallow smaller stuff, and become HUGE.</p>
          <p>
            Controls: <span class="kbd">WASD</span>/<span class="kbd">Arrows</span> or mouse/touch steering.
          </p>
          <div class="btnRow" style="margin-top:10px">
            <button id="btnPlay">PLAY</button>
            <button class="secondary" id="btnShop">SHOP</button>
          </div>
          <div id="homeOnly" class="help" style="margin-top:10px">
            - Swallow smaller things to grow.<br/>
            - Eat smaller holes too.<br/>
            - Bigger = slower, but stronger.<br/>
            - 2-minute round. Biggest score wins.
          </div>

          <div id="shopOverlay" style="display:none;margin-top:12px;text-align:left">
            <div class="row" style="margin-bottom:10px">
              <span style="font-weight:900">Your Coins</span>
              <span class="pill" id="shopCoins" style="min-width:110px">0</span>
            </div>
            <div id="shopOverlayList"></div>
            <div class="btnRow" style="margin-top:12px">
              <button class="secondary" id="btnBackHome">BACK</button>
              <button id="btnPlayFromShop">PLAY</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="card side">
      <div class="hud">
        <div class="row"><span>Score</span><span class="pill" id="score">0</span></div>
        <div class="row"><span>Size</span><span class="pill" id="size">12</span></div>
        <div class="row"><span>Coins</span><span class="pill" id="coins">0</span></div>
        <div class="row"><span>Time</span><span class="pill" id="time">2:00</span></div>
        <div class="btnRow">
          <button class="secondary" id="btnPause">Pause</button>
          <button class="danger" id="btnRestart">Restart</button>
        </div>
        <div class="btnRow">
          <button class="secondary" id="btnChangeName">Change Name</button>
          <button class="secondary" id="btnResetSave">Reset Save</button>
        </div>
      </div>

      <div class="leader">
        <h3>Leaderboard</h3>
        <div id="leaderList"></div>
      </div>

      <div class="shop">
        <h3>Shop (Skins)</h3>
        <div id="shopList"></div>
      </div>

      <div class="help">
        This is a simplified Hole.io-style game (original art & code). No external libraries.
      </div>
    </div>
  </div>

<script>
// -----------------------------
// Mini Hole.io â€” single file
// -----------------------------
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const ovTitle = document.getElementById('ovTitle');
const ovText = document.getElementById('ovText');
const btnPlay = document.getElementById('btnPlay');
const btnShop = document.getElementById('btnShop');
const homeOnlyEl = document.getElementById('homeOnly');
const shopOverlayEl = document.getElementById('shopOverlay');
const shopOverlayList = document.getElementById('shopOverlayList');
const shopCoinsEl = document.getElementById('shopCoins');
const btnBackHome = document.getElementById('btnBackHome');
const btnPlayFromShop = document.getElementById('btnPlayFromShop');
const btnPause = document.getElementById('btnPause');
const btnRestart = document.getElementById('btnRestart');
const btnChangeName = document.getElementById('btnChangeName');
const btnResetSave = document.getElementById('btnResetSave');
const scoreEl = document.getElementById('score');
const sizeEl = document.getElementById('size');
const coinsEl = document.getElementById('coins');
const timeEl = document.getElementById('time');
const leaderList = document.getElementById('leaderList');
const shopList = document.getElementById('shopList');

const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
const rand = (a,b) => a + Math.random()*(b-a);
const now = () => performance.now();
const dist2 = (ax,ay,bx,by) => { const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; };

function fmtTime(ms){
  const s = Math.max(0, Math.floor(ms/1000));
  const m = Math.floor(s/60);
  const ss = String(s%60).padStart(2,'0');
  return `${m}:${ss}`;
}

function resize(){
  const maxW = Math.min(960, Math.floor(window.innerWidth * 0.96));
  const maxH = Math.min(600, Math.floor(window.innerHeight * 0.86));
  let w = maxW;
  let h = Math.floor(w * 5/8);
  if (h > maxH){ h = maxH; w = Math.floor(h * 8/5); }
  canvas.width = Math.max(520, w);
  canvas.height = Math.max(320, h);
}
window.addEventListener('resize', resize);
resize();

// -----------------------------
// World setup
// -----------------------------
// Big world, camera follows player.
const WORLD = { w: 3200, h: 2200 };

const COLORS = ['#22ffb6','#ff4d6d','#ffd84d','#5bf7ff','#a2ff4d','#be00be','#ff7f00','#0066ff','#ff00ff','#00ff00','#00ffff'];
const NAMES = ['You','Nova','Zig','Bloop','Mimi','Orion','Pip','Glim','Roo','Byte','Luna','Cosmo','Bean','Fizz','Kip'];

// Objects to swallow
// Each object has a "size" which acts like radius for being swallowed.
const foods = [];      // small items
const props = [];      // bigger buildings
const holes = [];      // players (you + AI)
const particles = [];

let running = false;
let paused = false;
let gameOver = false;

const ROUND_MS = 2 * 60 * 1000;
let roundEnd = 0;
let lastT = 0;

// -----------------------------
// Coins + skins (persistent)
// -----------------------------
const LS_COINS = 'miniHoleioCoins';
const LS_OWNED = 'miniHoleioOwnedSkins';
const LS_SELECTED = 'miniHoleioSelectedSkin';
const LS_NAME = 'miniHoleioPlayerName';

const SKINS = [
  { id:'classic', name:'Classic', cost:0,  rim:'#ffffff', glow:'#ffffff', inner:'rgba(0,0,0,0.78)' },
  { id:'neonMint', name:'Neon Mint', cost:40, rim:'#22ffb6', glow:'#22ffb6', inner:'rgba(0,0,0,0.78)' },
  { id:'sunGold', name:'Sun Gold', cost:60, rim:'#ffd84d', glow:'#ffd84d', inner:'rgba(0,0,0,0.78)' },
  { id:'lava', name:'Lava', cost:90, rim:'#ff4d6d', glow:'#ff4d6d', inner:'rgba(0,0,0,0.72)' },
  { id:'galaxy', name:'Galaxy', cost:120, rim:'#be00be', glow:'#5bf7ff', inner:'rgba(0,0,0,0.82)' },
];

let coins = Number(localStorage.getItem(LS_COINS) || '0');
let ownedSkins = (() => {
  try {
    const raw = localStorage.getItem(LS_OWNED);
    const arr = raw ? JSON.parse(raw) : ['classic'];
    return new Set(Array.isArray(arr) ? arr : ['classic']);
  } catch {
    return new Set(['classic']);
  }
})();
let selectedSkinId = localStorage.getItem(LS_SELECTED) || 'classic';
if (!ownedSkins.has(selectedSkinId)) selectedSkinId = 'classic';
let playerName = (localStorage.getItem(LS_NAME) || 'You').trim() || 'You';

function saveEconomy(){
  localStorage.setItem(LS_COINS, String(coins));
  localStorage.setItem(LS_OWNED, JSON.stringify(Array.from(ownedSkins)));
  localStorage.setItem(LS_SELECTED, selectedSkinId);
  localStorage.setItem(LS_NAME, playerName);
}

function skinById(id){
  return SKINS.find(s => s.id === id) || SKINS[0];
}

function renderShopInto(container){
  container.innerHTML = '';
  for (const s of SKINS){
    const owned = ownedSkins.has(s.id);
    const selected = selectedSkinId === s.id;
    const div = document.createElement('div');
    div.className = 'shopItem';
    const left = document.createElement('div');
    left.innerHTML = `<span class="dot" style="background:${s.rim}"></span>${s.name}
      <span class="tag ${owned ? 'owned' : 'locked'}">${owned ? (selected ? 'SELECTED' : 'OWNED') : (s.cost + ' COINS')}</span>
      <small>Rim: ${s.rim}</small>`;
    const btn = document.createElement('button');
    btn.className = 'secondary tinyBtn';
    if (!owned){
      btn.textContent = 'Buy';
      btn.disabled = coins < s.cost;
      btn.addEventListener('click', () => {
        if (coins < s.cost) return;
        coins -= s.cost;
        ownedSkins.add(s.id);
        selectedSkinId = s.id;
        saveEconomy();
        renderShop();
        updateHUD();
      });
    } else {
      btn.textContent = selected ? 'Using' : 'Select';
      btn.disabled = selected;
      btn.addEventListener('click', () => {
        selectedSkinId = s.id;
        saveEconomy();
        renderShop();
      });
    }
    div.appendChild(left);
    div.appendChild(btn);
    container.appendChild(div);
  }
}

function renderShop(){
  // Sidebar shop
  renderShopInto(shopList);
  // Overlay shop (home screen)
  renderShopInto(shopOverlayList);
  shopCoinsEl.textContent = String(coins);
}

// Input
const keys = new Set();
document.addEventListener('keydown', (e) => {
  if (e.key === ' ') e.preventDefault();
  keys.add(e.key);
});
document.addEventListener('keyup', (e) => keys.delete(e.key));

let pointer = { active:false, x:0, y:0 };
canvas.addEventListener('pointerdown', (e) => { pointer.active = true; setPointer(e); });
canvas.addEventListener('pointermove', (e) => { if (pointer.active) setPointer(e); });
window.addEventListener('pointerup', () => pointer.active = false);

function setPointer(e){
  const r = canvas.getBoundingClientRect();
  pointer.x = (e.clientX - r.left) * (canvas.width / r.width);
  pointer.y = (e.clientY - r.top) * (canvas.height / r.height);
}

// -----------------------------
// Entities
// -----------------------------
function makeHole(name, color, isYou){
  const skin = isYou ? skinById(selectedSkinId) : null;
  const h = {
    name, color,
    isYou,
    alive: true,
    x: rand(200, WORLD.w-200),
    y: rand(200, WORLD.h-200),
    vx: 0, vy: 0,
    r: isYou ? 14 : rand(12, 18),
    score: 0,
    skin,
    ai: {
      target: {x: rand(0,WORLD.w), y: rand(0,WORLD.h)},
      retarget: rand(0.4, 1.6)
    }
  };
  // Keep spawn away from edges
  h.x = clamp(h.x, 120, WORLD.w-120);
  h.y = clamp(h.y, 120, WORLD.h-120);
  return h;
}

function spawnFood(n){
  for (let i=0;i<n;i++){
    foods.push({
      x: rand(40, WORLD.w-40),
      y: rand(40, WORLD.h-40),
      r: rand(4, 10),
      col: COLORS[Math.floor(rand(0, COLORS.length))],
      kind: Math.random() < 0.5 ? 'car' : 'person',
      wob: rand(0, Math.PI*2)
    });
  }
}

function spawnProps(){
  // Big "buildings" to eventually eat
  const kinds = ['house','tower','tree'];
  const count = 75;
  for (let i=0;i<count;i++){
    const k = kinds[Math.floor(rand(0,kinds.length))];
    const base = (k === 'tree') ? rand(16, 26) : (k === 'house' ? rand(22, 40) : rand(35, 60));
    props.push({
      x: rand(120, WORLD.w-120),
      y: rand(120, WORLD.h-120),
      r: base,
      kind: k,
      col: k === 'tree' ? '#2eea74' : '#ffd84d'
    });
  }
}

function burst(x,y, col, n=16){
  for (let i=0;i<n;i++){
    particles.push({
      x,y,
      vx: rand(-260, 260),
      vy: rand(-260, 260),
      life: rand(0.25, 0.8),
      r: rand(2, 5),
      col
    });
  }
}

// -----------------------------
// Swallow rules
// -----------------------------
function canSwallow(bigR, smallR){
  // Need a size advantage
  return bigR > smallR * 1.12;
}

function swallowDistance(bigR, smallR){
  // Slightly inside the rim
  return (bigR - smallR * 0.35);
}

function gainFromRadius(r){
  // Score and growth scale with area-ish
  return Math.max(1, Math.floor(r * r * 0.08));
}

function growHole(h, eatenR){
  // Increase radius by a tiny amount based on eaten area
  const area = eatenR * eatenR;
  h.r = Math.min(120, Math.sqrt(h.r*h.r + area * 0.22));
}

// -----------------------------
// Camera
// -----------------------------
function getYou(){ return holes.find(h => h.isYou); }
function camera(){
  const you = getYou();
  if (!you) return { x:0, y:0, zoom:1 };
  // Zoom out as you grow
  const zoom = clamp(1.35 - (you.r / 140), 0.72, 1.25);
  const viewW = canvas.width / zoom;
  const viewH = canvas.height / zoom;
  const cx = clamp(you.x - viewW/2, 0, WORLD.w - viewW);
  const cy = clamp(you.y - viewH/2, 0, WORLD.h - viewH);
  return { x: cx, y: cy, zoom };
}

// -----------------------------
// UI
// -----------------------------
function updateHUD(){
  const you = getYou();
  scoreEl.textContent = String(you ? Math.floor(you.score) : 0);
  sizeEl.textContent = String(you ? Math.floor(you.r) : 0);
  coinsEl.textContent = String(coins);
  const tLeft = roundEnd - now();
  timeEl.textContent = fmtTime(tLeft);
}

function updateLeaderboard(){
  const live = holes.filter(h => h.alive);
  live.sort((a,b) => b.score - a.score);
  const top = live.slice(0, 8);
  leaderList.innerHTML = '';
  for (let i=0;i<top.length;i++){
    const h = top[i];
    const div = document.createElement('div');
    div.className = 'rank';
    const left = document.createElement('div');
    left.innerHTML = `${i+1}. <span class="dot" style="background:${h.color}"></span>${h.name}`;
    const right = document.createElement('div');
    right.textContent = `${Math.floor(h.score)}`;
    div.appendChild(left);
    div.appendChild(right);
    leaderList.appendChild(div);
  }
}

// -----------------------------
// Game flow
// -----------------------------
function resetGame(){
  foods.length = 0;
  props.length = 0;
  holes.length = 0;
  particles.length = 0;

  spawnProps();
  spawnFood(650);

  // Create player + AI
  holes.push(makeHole(playerName, '#ffffff', true));
  const aiCount = 16; // more AI opponents
  for (let i=0;i<aiCount;i++){
    holes.push(makeHole(NAMES[1+i] ?? `AI${i+1}`, COLORS[i % COLORS.length], false));
  }

  roundEnd = now() + ROUND_MS;
  paused = false;
  gameOver = false;
  lastT = 0;
  btnPause.textContent = 'Pause';
  updateHUD();
  updateLeaderboard();
  renderShop();
}

function start(){
  resetGame();
  running = true;
  overlay.classList.add('hidden');
}

function endRound(){
  gameOver = true;
  paused = false;
  const sorted = holes.slice().sort((a,b) => b.score - a.score);
  const winner = sorted[0];
  const you = getYou();
  const yourScore = Math.floor(you?.score ?? 0);
  const place = Math.max(1, sorted.findIndex(h => h.isYou) + 1);
  // Coins earned: based on score + placement bonus (minimum 1 if you played)
  const scoreCoins = Math.floor(yourScore / 180);
  const placeBonus = place === 1 ? 25 : place <= 3 ? 12 : 4;
  const earned = Math.max(1, scoreCoins + placeBonus);
  coins += earned;
  saveEconomy();
  renderShop();
  updateHUD();

  ovTitle.textContent = (winner?.isYou) ? 'YOU WIN!' : 'ROUND OVER';
  ovText.innerHTML = `Winner: <b>${winner?.name ?? '???'}</b><br/>Your place: <b>#${place}</b><br/>Your score: <b>${yourScore}</b><br/><br/>You earned <b>${earned} coins</b>!`;
  btnPlay.textContent = 'Play Again';
  overlay.classList.remove('hidden');
}

btnPlay.addEventListener('click', start);
btnShop.addEventListener('click', () => {
  // Home screen -> Shop screen
  homeOnlyEl.style.display = 'none';
  shopOverlayEl.style.display = 'block';
  renderShop();
});
btnBackHome.addEventListener('click', () => {
  shopOverlayEl.style.display = 'none';
  homeOnlyEl.style.display = 'block';
});
btnPlayFromShop.addEventListener('click', start);
btnRestart.addEventListener('click', () => { if (running) start(); });
btnPause.addEventListener('click', () => {
  if (!running || gameOver) return;
  paused = !paused;
  btnPause.textContent = paused ? 'Resume' : 'Pause';
});

btnChangeName.addEventListener('click', () => {
  const current = playerName;
  const next = (prompt('Enter your name (1-12 characters):', current) || '').trim();
  if (!next) return;
  const safe = next.slice(0, 12);
  playerName = safe;
  saveEconomy();
  // Update current player hole name if a round is running
  const you = getYou();
  if (you) you.name = playerName;
  updateLeaderboard();
});

btnResetSave.addEventListener('click', () => {
  if (!confirm('Reset coins + skins + name?')) return;
  coins = 0;
  ownedSkins = new Set(['classic']);
  selectedSkinId = 'classic';
  playerName = 'You';
  saveEconomy();
  renderShop();
  updateHUD();
  const you = getYou();
  if (you){
    you.name = playerName;
    you.skin = skinById(selectedSkinId);
  }
  updateLeaderboard();
});

// -----------------------------
// AI steering
// -----------------------------
function aiUpdate(h, dt){
  // Simple logic: head toward nearest edible item; otherwise wander
  h.ai.retarget -= dt;
  if (h.ai.retarget <= 0){
    h.ai.retarget = rand(0.4, 1.3);
    // Find closest edible (food/prop/hole)
    let best = null;
    let bestD = Infinity;

    for (let i=0;i<foods.length;i++){
      const f = foods[i];
      if (!canSwallow(h.r, f.r)) continue;
      const d = dist2(h.x,h.y,f.x,f.y);
      if (d < bestD){ bestD = d; best = {x:f.x,y:f.y}; }
    }
    for (let i=0;i<props.length;i++){
      const p = props[i];
      if (!canSwallow(h.r, p.r)) continue;
      const d = dist2(h.x,h.y,p.x,p.y);
      if (d < bestD){ bestD = d; best = {x:p.x,y:p.y}; }
    }
    for (const other of holes){
      if (!other.alive || other === h) continue;
      if (!canSwallow(h.r, other.r)) continue;
      const d = dist2(h.x,h.y,other.x,other.y);
      if (d < bestD){ bestD = d; best = {x:other.x,y:other.y}; }
    }

    if (best) h.ai.target = best;
    else h.ai.target = { x: rand(0, WORLD.w), y: rand(0, WORLD.h) };
  }
}

// -----------------------------
// Update step
// -----------------------------
function update(dt){
  if (now() >= roundEnd){
    endRound();
    return;
  }

  // Replenish food slowly
  if (foods.length < 550) spawnFood(60);

  // Player input
  const you = getYou();
  if (you && you.alive){
    let ix = 0, iy = 0;
    const left = keys.has('ArrowLeft') || keys.has('a') || keys.has('A');
    const right = keys.has('ArrowRight') || keys.has('d') || keys.has('D');
    const up = keys.has('ArrowUp') || keys.has('w') || keys.has('W');
    const down = keys.has('ArrowDown') || keys.has('s') || keys.has('S');
    if (left) ix -= 1;
    if (right) ix += 1;
    if (up) iy -= 1;
    if (down) iy += 1;

    // Pointer steering: move toward pointer from screen center
    if (pointer.active){
      const cx = canvas.width/2;
      const cy = canvas.height/2;
      const dx = pointer.x - cx;
      const dy = pointer.y - cy;
      const m = Math.hypot(dx,dy) || 1;
      ix += dx / m;
      iy += dy / m;
    }

    const im = Math.hypot(ix,iy);
    if (im > 1){ ix /= im; iy /= im; }

    // Movement speed decreases as you get bigger
    const base = 560;
    const speed = base * clamp(18 / you.r, 0.33, 1.0);
    // Smooth velocity
    you.vx += ix * speed * dt * 6;
    you.vy += iy * speed * dt * 6;
  }

  // Update holes (you + AI)
  for (const h of holes){
    if (!h.alive) continue;

    if (!h.isYou){
      aiUpdate(h, dt);
      // steer to target
      const dx = h.ai.target.x - h.x;
      const dy = h.ai.target.y - h.y;
      const m = Math.hypot(dx,dy) || 1;
      const base = 520;
      const speed = base * clamp(18 / h.r, 0.38, 1.0);
      h.vx += (dx/m) * speed * dt * 5;
      h.vy += (dy/m) * speed * dt * 5;
    }

    // Damping (friction)
    // The old formula was far too strong and basically stopped movement.
    // This keeps things smooth while still letting you move instantly.
    const friction = Math.pow(0.90, dt * 60); // ~0.90 per frame at 60fps
    h.vx *= friction;
    h.vy *= friction;

    // Clamp max speed
    const maxV = 700 * clamp(18 / h.r, 0.32, 1.0);
    h.vx = clamp(h.vx, -maxV, maxV);
    h.vy = clamp(h.vy, -maxV, maxV);

    // Integrate
    h.x += h.vx * dt;
    h.y += h.vy * dt;
    h.x = clamp(h.x, h.r + 10, WORLD.w - h.r - 10);
    h.y = clamp(h.y, h.r + 10, WORLD.h - h.r - 10);
  }

  // Swallow foods
  for (const h of holes){
    if (!h.alive) continue;
    const sr = h.r;
    // Foods
    for (let i=foods.length-1;i>=0;i--){
      const f = foods[i];
      if (!canSwallow(sr, f.r)) continue;
      const d = Math.sqrt(dist2(h.x,h.y,f.x,f.y));
      if (d < swallowDistance(sr, f.r)){
        foods.splice(i,1);
        const gain = gainFromRadius(f.r);
        h.score += gain;
        growHole(h, f.r);
        burst(f.x, f.y, f.col, 10);
      }
    }
    // Props
    for (let i=props.length-1;i>=0;i--){
      const p = props[i];
      if (!canSwallow(sr, p.r)) continue;
      const d = Math.sqrt(dist2(h.x,h.y,p.x,p.y));
      if (d < swallowDistance(sr, p.r)){
        props.splice(i,1);
        const gain = gainFromRadius(p.r) * 3;
        h.score += gain;
        growHole(h, p.r);
        burst(p.x, p.y, '#ffd84d', 18);
      }
    }
  }

  // Hole vs Hole eating
  for (let i=0;i<holes.length;i++){
    const a = holes[i];
    if (!a.alive) continue;
    for (let j=0;j<holes.length;j++){
      if (i===j) continue;
      const b = holes[j];
      if (!b.alive) continue;
      if (!canSwallow(a.r, b.r)) continue;
      const d = Math.sqrt(dist2(a.x,a.y,b.x,b.y));
      if (d < swallowDistance(a.r, b.r)){
        b.alive = false;
        a.score += Math.floor(b.score * 0.25) + gainFromRadius(b.r) * 8;
        growHole(a, b.r * 1.1);
        burst(b.x, b.y, b.color, 30);
      }
    }
  }

  // Particles
  for (let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.life -= dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vx *= Math.pow(0.88, dt*60);
    p.vy *= Math.pow(0.88, dt*60);
    if (p.life <= 0) particles.splice(i,1);
  }

  updateHUD();
  updateLeaderboard();
}

// -----------------------------
// Drawing
// -----------------------------
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const cam = camera();

  ctx.save();
  ctx.scale(cam.zoom, cam.zoom);
  ctx.translate(-cam.x, -cam.y);

  // City ground (grid streets)
  ctx.fillStyle = '#0b1020';
  ctx.fillRect(0,0,WORLD.w,WORLD.h);
  // Roads
  ctx.fillStyle = 'rgba(255,255,255,0.05)';
  for (let x=0; x<WORLD.w; x+=160){
    ctx.fillRect(x, 0, 26, WORLD.h);
  }
  for (let y=0; y<WORLD.h; y+=160){
    ctx.fillRect(0, y, WORLD.w, 26);
  }

  // Props
  for (const p of props){
    drawProp(p);
  }

  // Foods
  for (const f of foods){
    drawFood(f);
  }

  // Holes (draw hole shadow + rim + name)
  for (const h of holes){
    if (!h.alive) continue;
    drawHole(h);
  }

  // Particles
  for (const p of particles){
    ctx.globalAlpha = clamp(p.life / 0.8, 0, 1);
    ctx.fillStyle = p.col;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  ctx.restore();

  // Mini map hint
  drawMiniMap(cam);
}

function drawFood(f){
  f.wob += 0.03;
  const wob = Math.sin(f.wob) * 0.6;
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.beginPath();
  ctx.ellipse(f.x, f.y + f.r*0.8, f.r*0.9, f.r*0.35, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.fillStyle = f.col;
  ctx.beginPath();
  ctx.arc(f.x, f.y + wob, f.r, 0, Math.PI*2);
  ctx.fill();
}

function drawProp(p){
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.beginPath();
  ctx.ellipse(p.x, p.y + p.r*0.9, p.r*0.9, p.r*0.32, 0, 0, Math.PI*2);
  ctx.fill();

  if (p.kind === 'tree'){
    // trunk
    ctx.fillStyle = '#6b3f1a';
    ctx.fillRect(p.x - p.r*0.18, p.y - p.r*0.2, p.r*0.36, p.r*0.9);
    // crown
    ctx.fillStyle = '#2eea74';
    ctx.beginPath();
    ctx.arc(p.x, p.y - p.r*0.35, p.r*0.7, 0, Math.PI*2);
    ctx.fill();
  } else if (p.kind === 'house'){
    ctx.fillStyle = '#ffd84d';
    ctx.fillRect(p.x - p.r*0.65, p.y - p.r*0.55, p.r*1.3, p.r*1.0);
    ctx.fillStyle = '#ff4d6d';
    ctx.beginPath();
    ctx.moveTo(p.x - p.r*0.75, p.y - p.r*0.55);
    ctx.lineTo(p.x, p.y - p.r*1.05);
    ctx.lineTo(p.x + p.r*0.75, p.y - p.r*0.55);
    ctx.closePath();
    ctx.fill();
  } else {
    // tower
    ctx.fillStyle = '#5bf7ff';
    ctx.fillRect(p.x - p.r*0.45, p.y - p.r*1.05, p.r*0.9, p.r*1.65);
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    ctx.fillRect(p.x - p.r*0.20, p.y - p.r*0.95, p.r*0.4, p.r*0.4);
  }
}

function drawHole(h){
  // outer rim
  ctx.save();
  ctx.translate(h.x, h.y);

  const skin = h.skin;
  const rim = skin ? skin.rim : h.color;
  const glow = skin ? skin.glow : h.color;
  const inner = skin ? skin.inner : 'rgba(0,0,0,0.75)';

  // Rim glow
  ctx.shadowColor = glow;
  ctx.shadowBlur = h.isYou ? 18 : 12;

  // Rim
  ctx.strokeStyle = rim;
  ctx.lineWidth = Math.max(2, h.r * (h.isYou ? 0.20 : 0.18));
  ctx.beginPath();
  ctx.arc(0, 0, h.r, 0, Math.PI*2);
  ctx.stroke();
  ctx.shadowBlur = 0;

  // Inner hole
  ctx.fillStyle = inner;
  ctx.beginPath();
  ctx.arc(0, 0, h.r * 0.92, 0, Math.PI*2);
  ctx.fill();

  // Soft inner gradient
  const g = ctx.createRadialGradient(0, 0, h.r*0.1, 0, 0, h.r);
  g.addColorStop(0, 'rgba(0,0,0,0.10)');
  g.addColorStop(1, 'rgba(0,0,0,0.85)');
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(0, 0, h.r*0.92, 0, Math.PI*2);
  ctx.fill();

  // Name
  ctx.fillStyle = 'rgba(255,255,255,0.92)';
  ctx.font = `900 ${Math.max(12, Math.floor(h.r*0.55))}px Verdana`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'bottom';
  ctx.fillText(h.name, 0, -h.r - 6);

  ctx.restore();
}

function drawMiniMap(cam){
  // Small minimap in corner
  const w = 170, h = 120;
  const x = canvas.width - w - 14;
  const y = 14;
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  roundRect(x, y, w, h, 14, true, false);
  ctx.strokeStyle = 'rgba(255,255,255,0.14)';
  ctx.lineWidth = 2;
  roundRect(x, y, w, h, 14, false, true);

  // view rect
  const vw = canvas.width / cam.zoom;
  const vh = canvas.height / cam.zoom;
  const sx = (xx) => x + 8 + (xx / WORLD.w) * (w - 16);
  const sy = (yy) => y + 8 + (yy / WORLD.h) * (h - 16);

  ctx.strokeStyle = 'rgba(91,247,255,0.55)';
  ctx.lineWidth = 2;
  ctx.strokeRect(sx(cam.x), sy(cam.y), (vw / WORLD.w) * (w - 16), (vh / WORLD.h) * (h - 16));

  // dots
  for (const h0 of holes){
    if (!h0.alive) continue;
    ctx.fillStyle = h0.color;
    ctx.beginPath();
    ctx.arc(sx(h0.x), sy(h0.y), h0.isYou ? 3.3 : 2.4, 0, Math.PI*2);
    ctx.fill();
  }
}

function roundRect(x,y,w,h,r, fill, stroke){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.lineTo(x+w-rr, y);
  ctx.quadraticCurveTo(x+w, y, x+w, y+rr);
  ctx.lineTo(x+w, y+h-rr);
  ctx.quadraticCurveTo(x+w, y+h, x+w-rr, y+h);
  ctx.lineTo(x+rr, y+h);
  ctx.quadraticCurveTo(x, y+h, x, y+h-rr);
  ctx.lineTo(x, y+rr);
  ctx.quadraticCurveTo(x, y, x+rr, y);
  ctx.closePath();
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}

// -----------------------------
// Main loop
// -----------------------------
function frame(t){
  requestAnimationFrame(frame);
  if (!running){ draw(); return; }
  if (paused || gameOver){ draw(); return; }
  if (!lastT) lastT = t;
  const dt = Math.min(0.033, (t - lastT) / 1000);
  lastT = t;
  update(dt);
  draw();
}
requestAnimationFrame(frame);

// Initial UI
renderShop();
updateHUD();

</script>
</body>
</html>


